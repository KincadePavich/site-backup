<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithms - RSA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms - RSA</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga37fffd370cc1635d98ac69b142e91b67"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga37fffd370cc1635d98ac69b142e91b67">wc_SetKeyUsage</a> (<a class="el" href="structCert.html">Cert</a> *cert, const char *value)</td></tr>
<tr class="memdesc:ga37fffd370cc1635d98ac69b142e91b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows you to set the key usage using a comma delimited string of tokens. Accepted tokens are: digitalSignature, nonRepudiation, contentCommitment, keyCertSign, cRLSign, dataEncipherment, keyAgreement, keyEncipherment, encipherOnly, decipherOnly. Example: "digitalSignature,nonRepudiation" nonRepudiation and contentCommitment are for the same usage.  <a href="#ga37fffd370cc1635d98ac69b142e91b67">More...</a><br /></td></tr>
<tr class="separator:ga37fffd370cc1635d98ac69b142e91b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54dd243045fe8ffb12f63f06a4213fa"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa">wc_InitRsaKey</a> (<a class="el" href="structRsaKey.html">RsaKey</a> *key, void *heap)</td></tr>
<tr class="memdesc:gac54dd243045fe8ffb12f63f06a4213fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a provided <a class="el" href="structRsaKey.html">RsaKey</a> struct. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC).  <a href="#gac54dd243045fe8ffb12f63f06a4213fa">More...</a><br /></td></tr>
<tr class="separator:gac54dd243045fe8ffb12f63f06a4213fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d3bd4a79c0e053688d278dad9752d4"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gad8d3bd4a79c0e053688d278dad9752d4">wc_FreeRsaKey</a> (<a class="el" href="structRsaKey.html">RsaKey</a> *key)</td></tr>
<tr class="memdesc:gad8d3bd4a79c0e053688d278dad9752d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees a provided <a class="el" href="structRsaKey.html">RsaKey</a> struct using mp_clear.  <a href="#gad8d3bd4a79c0e053688d278dad9752d4">More...</a><br /></td></tr>
<tr class="separator:gad8d3bd4a79c0e053688d278dad9752d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf339effdd51d5eb0eb61fff07dade9b3"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gaf339effdd51d5eb0eb61fff07dade9b3">wc_RsaPublicEncrypt</a> (const byte *in, word32 inLen, byte *out, word32 outLen, <a class="el" href="structRsaKey.html">RsaKey</a> *key, <a class="el" href="structWC__RNG.html">WC_RNG</a> *rng)</td></tr>
<tr class="memdesc:gaf339effdd51d5eb0eb61fff07dade9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts a message from in and stores the result in out. It requires an initialized public key and a random number generator. As a side effect, this function will return the bytes written to out in outLen.  <a href="#gaf339effdd51d5eb0eb61fff07dade9b3">More...</a><br /></td></tr>
<tr class="separator:gaf339effdd51d5eb0eb61fff07dade9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427ad06f7c675518623a0dd6556a3a67"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga427ad06f7c675518623a0dd6556a3a67">wc_RsaPrivateDecryptInline</a> (byte *in, word32 inLen, byte **out, <a class="el" href="structRsaKey.html">RsaKey</a> *key)</td></tr>
<tr class="memdesc:ga427ad06f7c675518623a0dd6556a3a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions is utilized by the wc_RsaPrivateDecrypt function for decrypting.  <a href="#ga427ad06f7c675518623a0dd6556a3a67">More...</a><br /></td></tr>
<tr class="separator:ga427ad06f7c675518623a0dd6556a3a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a3ef7b29bfcfe17b9cc1ec834c0928e"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga2a3ef7b29bfcfe17b9cc1ec834c0928e">wc_RsaPrivateDecrypt</a> (const byte *in, word32 inLen, byte *out, word32 outLen, <a class="el" href="structRsaKey.html">RsaKey</a> *key)</td></tr>
<tr class="memdesc:ga2a3ef7b29bfcfe17b9cc1ec834c0928e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions provides private RSA decryption.  <a href="#ga2a3ef7b29bfcfe17b9cc1ec834c0928e">More...</a><br /></td></tr>
<tr class="separator:ga2a3ef7b29bfcfe17b9cc1ec834c0928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf16753fea3f44c320af565f9930d5dc8"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gaf16753fea3f44c320af565f9930d5dc8">wc_RsaSSL_Sign</a> (const byte *in, word32 inLen, byte *out, word32 outLen, <a class="el" href="structRsaKey.html">RsaKey</a> *key, <a class="el" href="structWC__RNG.html">WC_RNG</a> *rng)</td></tr>
<tr class="memdesc:gaf16753fea3f44c320af565f9930d5dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signs the provided array with the private key.  <a href="#gaf16753fea3f44c320af565f9930d5dc8">More...</a><br /></td></tr>
<tr class="separator:gaf16753fea3f44c320af565f9930d5dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab44880f347cd15a53c4e4962f6f779a6"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gab44880f347cd15a53c4e4962f6f779a6">wc_RsaSSL_VerifyInline</a> (byte *in, word32 inLen, byte **out, <a class="el" href="structRsaKey.html">RsaKey</a> *key)</td></tr>
<tr class="memdesc:gab44880f347cd15a53c4e4962f6f779a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to verify that the message was signed by RSA key. The output uses the same byte array as the input.  <a href="#gab44880f347cd15a53c4e4962f6f779a6">More...</a><br /></td></tr>
<tr class="separator:gab44880f347cd15a53c4e4962f6f779a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60b9072c038124a9f833a7cbd49d052"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gaa60b9072c038124a9f833a7cbd49d052">wc_RsaSSL_Verify</a> (const byte *in, word32 inLen, byte *out, word32 outLen, <a class="el" href="structRsaKey.html">RsaKey</a> *key)</td></tr>
<tr class="memdesc:gaa60b9072c038124a9f833a7cbd49d052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to verify that the message was signed by key.  <a href="#gaa60b9072c038124a9f833a7cbd49d052">More...</a><br /></td></tr>
<tr class="separator:gaa60b9072c038124a9f833a7cbd49d052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad16430ccec12d700953c2e42953eef63"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gad16430ccec12d700953c2e42953eef63">wc_RsaEncryptSize</a> (<a class="el" href="structRsaKey.html">RsaKey</a> *key)</td></tr>
<tr class="memdesc:gad16430ccec12d700953c2e42953eef63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the encryption size for the provided key structure.  <a href="#gad16430ccec12d700953c2e42953eef63">More...</a><br /></td></tr>
<tr class="separator:gad16430ccec12d700953c2e42953eef63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c56ab962875a5b91e8a123b9ee7b1b"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga49c56ab962875a5b91e8a123b9ee7b1b">wc_RsaPrivateKeyDecode</a> (const byte *input, word32 *inOutIdx, <a class="el" href="structRsaKey.html">RsaKey</a> *, word32)</td></tr>
<tr class="memdesc:ga49c56ab962875a5b91e8a123b9ee7b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a DER-formatted RSA private key, extracts the private key and stores it in the given <a class="el" href="structRsaKey.html">RsaKey</a> structure. It also sets the distance parsed in idx.  <a href="#ga49c56ab962875a5b91e8a123b9ee7b1b">More...</a><br /></td></tr>
<tr class="separator:ga49c56ab962875a5b91e8a123b9ee7b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054bd3f110ed3024bfe03f35bda1f728"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga054bd3f110ed3024bfe03f35bda1f728">wc_RsaPublicKeyDecode</a> (const byte *input, word32 *inOutIdx, <a class="el" href="structRsaKey.html">RsaKey</a> *, word32)</td></tr>
<tr class="memdesc:ga054bd3f110ed3024bfe03f35bda1f728"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a DER-formatted RSA public key, extracts the public key and stores it in the given <a class="el" href="structRsaKey.html">RsaKey</a> structure. It also sets the distance parsed in idx.  <a href="#ga054bd3f110ed3024bfe03f35bda1f728">More...</a><br /></td></tr>
<tr class="separator:ga054bd3f110ed3024bfe03f35bda1f728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e8ce832e128685c2d550e27f3881eeb"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga8e8ce832e128685c2d550e27f3881eeb">wc_RsaPublicKeyDecodeRaw</a> (const byte *n, word32 nSz, const byte *e, word32 eSz, <a class="el" href="structRsaKey.html">RsaKey</a> *key)</td></tr>
<tr class="memdesc:ga8e8ce832e128685c2d550e27f3881eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decodes the raw elements of an RSA public key, taking in the public modulus (n) and exponent (e). It stores these raw elements in the provided <a class="el" href="structRsaKey.html">RsaKey</a> structure, allowing one to use them in the encryption/decryption process.  <a href="#ga8e8ce832e128685c2d550e27f3881eeb">More...</a><br /></td></tr>
<tr class="separator:ga8e8ce832e128685c2d550e27f3881eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6773e7577c5e53f775d11b23f15f2c81"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga6773e7577c5e53f775d11b23f15f2c81">wc_RsaKeyToDer</a> (<a class="el" href="structRsaKey.html">RsaKey</a> *, byte *output, word32 inLen)</td></tr>
<tr class="memdesc:ga6773e7577c5e53f775d11b23f15f2c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts an <a class="el" href="structRsaKey.html">RsaKey</a> key to DER format. The result is written to output and it returns the number of bytes written.  <a href="#ga6773e7577c5e53f775d11b23f15f2c81">More...</a><br /></td></tr>
<tr class="separator:ga6773e7577c5e53f775d11b23f15f2c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7fb99d485b23378288e5654daf9a4f1"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gad7fb99d485b23378288e5654daf9a4f1">wc_RsaPublicEncrypt_ex</a> (const byte *in, word32 inLen, byte *out, word32 outLen, <a class="el" href="structRsaKey.html">RsaKey</a> *key, <a class="el" href="structWC__RNG.html">WC_RNG</a> *rng, int type, enum wc_HashType hash, int mgf, byte *label, word32 lableSz)</td></tr>
<tr class="memdesc:gad7fb99d485b23378288e5654daf9a4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs RSA encrypt while allowing the choice of which padding to use.  <a href="#gad7fb99d485b23378288e5654daf9a4f1">More...</a><br /></td></tr>
<tr class="separator:gad7fb99d485b23378288e5654daf9a4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6301321efaabad2792da9bede8a4356"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gaa6301321efaabad2792da9bede8a4356">wc_RsaPrivateDecrypt_ex</a> (const byte *in, word32 inLen, byte *out, word32 outLen, <a class="el" href="structRsaKey.html">RsaKey</a> *key, int type, enum wc_HashType hash, int mgf, byte *label, word32 lableSz)</td></tr>
<tr class="memdesc:gaa6301321efaabad2792da9bede8a4356"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses RSA to decrypt a message and gives the option of what padding type.  <a href="#gaa6301321efaabad2792da9bede8a4356">More...</a><br /></td></tr>
<tr class="separator:gaa6301321efaabad2792da9bede8a4356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf909918dbe4ca43eda83f947aa64313"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gacf909918dbe4ca43eda83f947aa64313">wc_RsaPrivateDecryptInline_ex</a> (byte *in, word32 inLen, byte **out, <a class="el" href="structRsaKey.html">RsaKey</a> *key, int type, enum wc_HashType hash, int mgf, byte *label, word32 lableSz)</td></tr>
<tr class="memdesc:gacf909918dbe4ca43eda83f947aa64313"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses RSA to decrypt a message inline and gives the option of what padding type. The in buffer will contain the decrypted message after being called and the out byte pointer will point to the location in the “in” buffer where the plain text is.  <a href="#gacf909918dbe4ca43eda83f947aa64313">More...</a><br /></td></tr>
<tr class="separator:gacf909918dbe4ca43eda83f947aa64313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c6facf796371602c988a2dd4c4bab9"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga32c6facf796371602c988a2dd4c4bab9">wc_RsaFlattenPublicKey</a> (<a class="el" href="structRsaKey.html">RsaKey</a> *, byte *, word32 *, byte *, word32 *)</td></tr>
<tr class="memdesc:ga32c6facf796371602c988a2dd4c4bab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the <a class="el" href="structRsaKey.html">RsaKey</a> structure into individual elements (e, n) used for the RSA algorithm.  <a href="#ga32c6facf796371602c988a2dd4c4bab9">More...</a><br /></td></tr>
<tr class="separator:ga32c6facf796371602c988a2dd4c4bab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3201ed0e530803ea16d276287d072fa4"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga3201ed0e530803ea16d276287d072fa4">wc_RsaKeyToPublicDer</a> (<a class="el" href="structRsaKey.html">RsaKey</a> *, byte *output, word32 inLen)</td></tr>
<tr class="memdesc:ga3201ed0e530803ea16d276287d072fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Rsa Public key to DER format. Writes to output, and returns count of bytes written.  <a href="#ga3201ed0e530803ea16d276287d072fa4">More...</a><br /></td></tr>
<tr class="separator:ga3201ed0e530803ea16d276287d072fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1898e2571ff02a4ba02a7abb7b8066e4"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga1898e2571ff02a4ba02a7abb7b8066e4">wc_MakeRsaKey</a> (<a class="el" href="structRsaKey.html">RsaKey</a> *key, int size, long e, <a class="el" href="structWC__RNG.html">WC_RNG</a> *rng)</td></tr>
<tr class="memdesc:ga1898e2571ff02a4ba02a7abb7b8066e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a RSA private key of length size (in bits) and given exponent (e). It then stores this key in the provided <a class="el" href="structRsaKey.html">RsaKey</a> structure, so that it may be used for encryption/decryption. A secure number to use for e is 65537. size is required to be greater than RSA_MIN_SIZE and less than RSA_MAX_SIZE. For this function to be available, the option WOLFSSL_KEY_GEN must be enabled at compile time. This can be accomplished with &ndash;enable-keygen if using ./configure.  <a href="#ga1898e2571ff02a4ba02a7abb7b8066e4">More...</a><br /></td></tr>
<tr class="separator:ga1898e2571ff02a4ba02a7abb7b8066e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad8d3bd4a79c0e053688d278dad9752d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8d3bd4a79c0e053688d278dad9752d4">&#9670;&nbsp;</a></span>wc_FreeRsaKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_FreeRsaKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees a provided <a class="el" href="structRsaKey.html">RsaKey</a> struct using mp_clear. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully freeing the key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structRsaKey.html">RsaKey</a> structure to free</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> enc;</div><div class="line">wc_RsaInitKey(&amp;enc, NULL); <span class="comment">// not using heap hint. No custom memory</span></div><div class="line">... <span class="keyword">set</span> key, <span class="keywordflow">do</span> encryption</div><div class="line"></div><div class="line"><a class="code" href="group__RSA.html#gad8d3bd4a79c0e053688d278dad9752d4">wc_FreeRsaKey</a>(&amp;enc);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC). ">wc_InitRsaKey</a> </dd></dl>

</div>
</div>
<a id="gac54dd243045fe8ffb12f63f06a4213fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac54dd243045fe8ffb12f63f06a4213fa">&#9670;&nbsp;</a></span>wc_InitRsaKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_InitRsaKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes a provided <a class="el" href="structRsaKey.html">RsaKey</a> struct. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC). </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully initializing the RSA structure for use with encryption and decryption </dd>
<dd>
BAD_FUNC_ARGS Returned if the RSA key pointer evaluates to NULL</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structRsaKey.html">RsaKey</a> structure to initialize </td></tr>
    <tr><td class="paramname">heap</td><td>pointer to a heap identifier, for use with memory overrides, allowing custom handling of memory allocation. This heap will be the default used when allocating memory for use with this RSA object</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> enc;</div><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line">ret = wc_RsaInitKey(&amp;enc, NULL); <span class="comment">// not using heap hint. No custom memory</span></div><div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div><div class="line">    <span class="comment">// error initializing RSA key</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wc_RsaInitCavium </dd>
<dd>
<a class="el" href="group__RSA.html#gad8d3bd4a79c0e053688d278dad9752d4" title="This function frees a provided RsaKey struct using mp_clear. ">wc_FreeRsaKey</a> </dd></dl>

</div>
</div>
<a id="ga1898e2571ff02a4ba02a7abb7b8066e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1898e2571ff02a4ba02a7abb7b8066e4">&#9670;&nbsp;</a></span>wc_MakeRsaKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_MakeRsaKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWC__RNG.html">WC_RNG</a> *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a RSA private key of length size (in bits) and given exponent (e). It then stores this key in the provided <a class="el" href="structRsaKey.html">RsaKey</a> structure, so that it may be used for encryption/decryption. A secure number to use for e is 65537. size is required to be greater than RSA_MIN_SIZE and less than RSA_MAX_SIZE. For this function to be available, the option WOLFSSL_KEY_GEN must be enabled at compile time. This can be accomplished with &ndash;enable-keygen if using ./configure. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully generating a RSA private key </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input arguments are NULL, the size parameter falls outside of the necessary bounds, or e is incorrectly chosen </dd>
<dd>
RNG_FAILURE_E Returned if there is an error generating a random block using the provided RNG structure </dd>
<dd>
MP_INIT_E </dd>
<dd>
MP_READ_E May be May be returned if there is an error in the math library used while generating the RSA key returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_CMP_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_INVMOD_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_EXPTMOD_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_MOD_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_MUL_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_ADD_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_MULMOD_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_TO_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_MEM May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_ZERO_E May be returned if there is an error in the math library used while generating the RSA key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structRsaKey.html">RsaKey</a> structure in which to store the generated private key </td></tr>
    <tr><td class="paramname">size</td><td>desired keylenth, in bits. Required to be greater than RSA_MIN_SIZE and less than RSA_MAX_SIZE </td></tr>
    <tr><td class="paramname">e</td><td>exponent parameter to use for generating the key. A secure choice is 65537 </td></tr>
    <tr><td class="paramname">rng</td><td>pointer to an RNG structure to use for random number generation while making the ke</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> priv;</div><div class="line">RNG rng;</div><div class="line"><span class="keywordtype">int</span> ret = 0;</div><div class="line"><span class="keywordtype">long</span> e = 65537; <span class="comment">// standard value to use for exponent</span></div><div class="line"></div><div class="line"><a class="code" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa">wc_InitRsaKey</a>(&amp;priv, NULL); <span class="comment">// not using heap hint. No custom memory</span></div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line">ret = <a class="code" href="group__RSA.html#ga1898e2571ff02a4ba02a7abb7b8066e4">wc_MakeRsaKey</a>(&amp;priv, 2048, e, &amp;rng); <span class="comment">// generate 2048 bit long private key</span></div><div class="line"><span class="keywordflow">if</span>( ret != 0 ) {</div><div class="line">    <span class="comment">// error generating private key</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="gad16430ccec12d700953c2e42953eef63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad16430ccec12d700953c2e42953eef63">&#9670;&nbsp;</a></span>wc_RsaEncryptSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaEncryptSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the encryption size for the provided key structure. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Encryption size for the provided key structure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to use for verification.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sz = <a class="code" href="group__RSA.html#gad16430ccec12d700953c2e42953eef63">wc_RsaEncryptSize</a>(&amp;key);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC). ">wc_InitRsaKey</a> </dd>
<dd>
wc_InitRsaKey_ex </dd>
<dd>
<a class="el" href="group__RSA.html#ga1898e2571ff02a4ba02a7abb7b8066e4" title="This function generates a RSA private key of length size (in bits) and given exponent (e)...">wc_MakeRsaKey</a> </dd>
<dd>
XMEMSET </dd></dl>

</div>
</div>
<a id="ga32c6facf796371602c988a2dd4c4bab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32c6facf796371602c988a2dd4c4bab9">&#9670;&nbsp;</a></span>wc_RsaFlattenPublicKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaFlattenPublicKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens the <a class="el" href="structRsaKey.html">RsaKey</a> structure into individual elements (e, n) used for the RSA algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned if the function executed normally, without error. </dd>
<dd>
BAD_FUNC_ARG: Returned if any of the parameters are passed in with a null value. </dd>
<dd>
RSA_BUFFER_E: Returned if the e or n buffers passed in are not the correct size. </dd>
<dd>
MP_MEM: Returned if an internal function has memory errors. </dd>
<dd>
MP_VAL: Returned if an internal function argument is not valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to use for verification. </td></tr>
    <tr><td class="paramname">e</td><td>a buffer for the value of e. e is a large positive integer in the RSA modular arithmetic operation. </td></tr>
    <tr><td class="paramname">eSz</td><td>the size of the e buffer. </td></tr>
    <tr><td class="paramname">n</td><td>a buffer for the value of n. n is a large positive integer in the RSA modular arithmetic operation. </td></tr>
    <tr><td class="paramname">nSz</td><td>the size of the n buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Rsa key; <span class="comment">// A valid RSA key.</span></div><div class="line">byte e[ <span class="comment">/* buffer sz. E.g. 256 ];</span></div><div class="line"><span class="comment">byte n[256];</span></div><div class="line"><span class="comment">int ret;</span></div><div class="line"><span class="comment">word32 eSz = sizeof(e);</span></div><div class="line"><span class="comment">word32 nSz = sizeof(n);</span></div><div class="line"><span class="comment">...</span></div><div class="line"><span class="comment">ret = wc_RsaFlattenPublicKey(&amp;key, e, &amp;eSz, n, &amp;nSz);</span></div><div class="line"><span class="comment">if (ret != 0) {</span></div><div class="line"><span class="comment">    // Failure case.</span></div><div class="line"><span class="comment">}</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC). ">wc_InitRsaKey</a> </dd>
<dd>
wc_InitRsaKey_ex </dd>
<dd>
<a class="el" href="group__RSA.html#ga1898e2571ff02a4ba02a7abb7b8066e4" title="This function generates a RSA private key of length size (in bits) and given exponent (e)...">wc_MakeRsaKey</a> </dd>
<dd>
XMEMSET </dd></dl>

</div>
</div>
<a id="ga6773e7577c5e53f775d11b23f15f2c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6773e7577c5e53f775d11b23f15f2c81">&#9670;&nbsp;</a></span>wc_RsaKeyToDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaKeyToDer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts an <a class="el" href="structRsaKey.html">RsaKey</a> key to DER format. The result is written to output and it returns the number of bytes written. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returned if key or output is null, or if key-&gt;type is not RSA_PRIVATE, or if inLen isn't large enough for output buffer. </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Initialized <a class="el" href="structRsaKey.html">RsaKey</a> structure. </td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output buffer. </td></tr>
    <tr><td class="paramname">inLen</td><td>Size of output buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">byte* der;</div><div class="line"><span class="comment">// Allocate memory for der</span></div><div class="line"><span class="keywordtype">int</span> derSz = <span class="comment">// Amount of memory allocated for der;</span></div><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> key;</div><div class="line">RNG rng;</div><div class="line"><span class="keywordtype">long</span> e = 65537; <span class="comment">// standard value to use for exponent</span></div><div class="line">ret = <a class="code" href="group__RSA.html#ga1898e2571ff02a4ba02a7abb7b8066e4">wc_MakeRsaKey</a>(&amp;key, 2048, e, &amp;rng); <span class="comment">// generate 2048 bit long private key</span></div><div class="line"><a class="code" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa">wc_InitRsaKey</a>(&amp;key, NULL);</div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__RSA.html#ga6773e7577c5e53f775d11b23f15f2c81">wc_RsaKeyToDer</a>(&amp;key, der, derSz) != 0)</div><div class="line">{</div><div class="line">    <span class="comment">// Handle the error thrown</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#ga3201ed0e530803ea16d276287d072fa4" title="Convert Rsa Public key to DER format. Writes to output, and returns count of bytes written...">wc_RsaKeyToPublicDer</a> </dd>
<dd>
<a class="el" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC). ">wc_InitRsaKey</a> </dd>
<dd>
<a class="el" href="group__RSA.html#ga1898e2571ff02a4ba02a7abb7b8066e4" title="This function generates a RSA private key of length size (in bits) and given exponent (e)...">wc_MakeRsaKey</a> </dd>
<dd>
<a class="el" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898" title="Gets the seed (from OS) and key cipher for rng. rng-&gt;drbg (deterministic random bit generator) alloca...">wc_InitRng</a> </dd></dl>

</div>
</div>
<a id="ga3201ed0e530803ea16d276287d072fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3201ed0e530803ea16d276287d072fa4">&#9670;&nbsp;</a></span>wc_RsaKeyToPublicDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaKeyToPublicDer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Rsa Public key to DER format. Writes to output, and returns count of bytes written. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Success, number of bytes written. </dd>
<dd>
BAD_FUNC_ARG Returned if key or output is null. </dd>
<dd>
MEMORY_E Returned when an error allocating memory occurs. </dd>
<dd>
&lt;0 Error</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The RSA key structure to convert. </td></tr>
    <tr><td class="paramname">output</td><td>Output buffer to hold DER. </td></tr>
    <tr><td class="paramname">inLen</td><td>Length of buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> key;</div><div class="line"></div><div class="line">wc_RsaInitKey(&amp;key, NULL);</div><div class="line"><span class="comment">// Use key</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> BUFFER_SIZE = <span class="comment">// Some adequate size for the buffer</span></div><div class="line">byte output[BUFFER_SIZE];</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__RSA.html#ga3201ed0e530803ea16d276287d072fa4">wc_RsaKeyToPublicDer</a>(&amp;key, output, <span class="keyword">sizeof</span>(output)) != 0)</div><div class="line">{</div><div class="line">    <span class="comment">// Handle Error</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#ga3201ed0e530803ea16d276287d072fa4" title="Convert Rsa Public key to DER format. Writes to output, and returns count of bytes written...">wc_RsaKeyToPublicDer</a> </dd>
<dd>
wc_RsaInitKey </dd></dl>

</div>
</div>
<a id="ga2a3ef7b29bfcfe17b9cc1ec834c0928e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a3ef7b29bfcfe17b9cc1ec834c0928e">&#9670;&nbsp;</a></span>wc_RsaPrivateDecrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaPrivateDecrypt </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>outLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions provides private RSA decryption. </p>
<dl class="section return"><dt>Returns</dt><dd>Success length of decrypted data. </dd>
<dd>
MEMORY_E -125, out of memory error </dd>
<dd>
BAD_FUNC_ARG -173, Bad function argument provided</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the decrypted data to be stored. </td></tr>
    <tr><td class="paramname">outLen</td><td>The length of out. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for decryption.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code" href="group__RSA.html#gaf339effdd51d5eb0eb61fff07dade9b3">wc_RsaPublicEncrypt</a>(in, inLen, out, <span class="keyword">sizeof</span>(out), &amp;key, &amp;rng);</div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">}</div><div class="line">ret = <a class="code" href="group__RSA.html#ga2a3ef7b29bfcfe17b9cc1ec834c0928e">wc_RsaPrivateDecrypt</a>(out, ret, plain, <span class="keyword">sizeof</span>(plain), &amp;key);</div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>RsaUnPad </dd>
<dd>
wc_RsaFunction </dd>
<dd>
<a class="el" href="group__RSA.html#ga427ad06f7c675518623a0dd6556a3a67" title="This functions is utilized by the wc_RsaPrivateDecrypt function for decrypting. ">wc_RsaPrivateDecryptInline</a> </dd></dl>

</div>
</div>
<a id="gaa6301321efaabad2792da9bede8a4356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6301321efaabad2792da9bede8a4356">&#9670;&nbsp;</a></span>wc_RsaPrivateDecrypt_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaPrivateDecrypt_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>outLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mgf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>lableSz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function uses RSA to decrypt a message and gives the option of what padding type. </p>
<dl class="section return"><dt>Returns</dt><dd>size On successful decryption, the size of the decrypted message is returned. </dd>
<dd>
MEMORY_E Returned if not enough memory on system to malloc a needed array. </dd>
<dd>
BAD_FUNC_ARG Returned if a bad argument was passed into the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer for decryption </td></tr>
    <tr><td class="paramname">inLen</td><td>length of the buffer to decrypt </td></tr>
    <tr><td class="paramname">out</td><td>decrypted msg created </td></tr>
    <tr><td class="paramname">outLen</td><td>length of buffer available to hold decrypted msg </td></tr>
    <tr><td class="paramname">key</td><td>initialized RSA key struct </td></tr>
    <tr><td class="paramname">type</td><td>type of padding to use (WC_RSA_OAEP_PAD or WC_RSA_PKCSV15_PAD) </td></tr>
    <tr><td class="paramname">hash</td><td>type of hash to use (choices can be found in <a class="el" href="hash_8h_source.html">hash.h</a>) </td></tr>
    <tr><td class="paramname">mgf</td><td>type of mask generation function to use </td></tr>
    <tr><td class="paramname">label</td><td>an optional label to associate with encrypted message </td></tr>
    <tr><td class="paramname">labelSz</td><td>size of the optional label used</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWC__RNG.html">WC_RNG</a> rng;</div><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> key;</div><div class="line">byte in[] = “I use Turing Machines to ask questions”</div><div class="line">byte out[256];</div><div class="line">byte plain[256];</div><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line">…</div><div class="line">ret = <a class="code" href="group__RSA.html#gad7fb99d485b23378288e5654daf9a4f1">wc_RsaPublicEncrypt_ex</a>(in, <span class="keyword">sizeof</span>(in), out, <span class="keyword">sizeof</span>(out), &amp;key, &amp;rng, WC_RSA_OAEP_PAD, WC_HASH_TYPE_SHA, WC_MGF1SHA1, NULL, 0);</div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="comment">//handle error</span></div><div class="line">}</div><div class="line">…</div><div class="line">ret = <a class="code" href="group__RSA.html#gaa6301321efaabad2792da9bede8a4356">wc_RsaPrivateDecrypt_ex</a>(out, ret, plain, <span class="keyword">sizeof</span>(plain), &amp;key, WC_RSA_OAEP_PAD, WC_HASH_TYPE_SHA, WC_MGF1SHA1, NULL, 0);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="comment">//handle error</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga427ad06f7c675518623a0dd6556a3a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga427ad06f7c675518623a0dd6556a3a67">&#9670;&nbsp;</a></span>wc_RsaPrivateDecryptInline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaPrivateDecryptInline </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions is utilized by the wc_RsaPrivateDecrypt function for decrypting. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Length of decrypted data. </dd>
<dd>
RSA_PAD_E RsaUnPad error, bad formatting</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the decrypted data to be stored. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for decryption.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#ga2a3ef7b29bfcfe17b9cc1ec834c0928e" title="This functions provides private RSA decryption. ">wc_RsaPrivateDecrypt</a> </dd></dl>

</div>
</div>
<a id="gacf909918dbe4ca43eda83f947aa64313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf909918dbe4ca43eda83f947aa64313">&#9670;&nbsp;</a></span>wc_RsaPrivateDecryptInline_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaPrivateDecryptInline_ex </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mgf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>lableSz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function uses RSA to decrypt a message inline and gives the option of what padding type. The in buffer will contain the decrypted message after being called and the out byte pointer will point to the location in the “in” buffer where the plain text is. </p>
<dl class="section return"><dt>Returns</dt><dd>size On successful decryption, the size of the decrypted message is returned. </dd>
<dd>
MEMORY_E: Returned if not enough memory on system to malloc a needed array. </dd>
<dd>
RSA_PAD_E: Returned if an error in the padding was encountered. </dd>
<dd>
BAD_PADDING_E: Returned if an error happened during parsing past padding. </dd>
<dd>
BAD_FUNC_ARG: Returned if a bad argument was passed into the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer for decryption </td></tr>
    <tr><td class="paramname">inLen</td><td>length of the buffer to decrypt </td></tr>
    <tr><td class="paramname">out</td><td>pointer to location of decrypted message in “in” buffer </td></tr>
    <tr><td class="paramname">key</td><td>initialized RSA key struct </td></tr>
    <tr><td class="paramname">type</td><td>type of padding to use (WC_RSA_OAEP_PAD or WC_RSA_PKCSV15_PAD) </td></tr>
    <tr><td class="paramname">hash</td><td>type of hash to use (choices can be found in <a class="el" href="hash_8h_source.html">hash.h</a>) </td></tr>
    <tr><td class="paramname">mgf</td><td>type of mask generation function to use </td></tr>
    <tr><td class="paramname">label</td><td>an optional label to associate with encrypted message </td></tr>
    <tr><td class="paramname">labelSz</td><td>size of the optional label used</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWC__RNG.html">WC_RNG</a> rng;</div><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> key;</div><div class="line">byte in[] = “I use Turing Machines to ask questions”</div><div class="line">byte out[256];</div><div class="line">byte* plain;</div><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line">…</div><div class="line">ret = <a class="code" href="group__RSA.html#gad7fb99d485b23378288e5654daf9a4f1">wc_RsaPublicEncrypt_ex</a>(in, <span class="keyword">sizeof</span>(in), out, <span class="keyword">sizeof</span>(out), &amp;key, &amp;rng, WC_RSA_OAEP_PAD, WC_HASH_TYPE_SHA, WC_MGF1SHA1, NULL, 0);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="comment">//handle error</span></div><div class="line">}</div><div class="line">…</div><div class="line">ret = <a class="code" href="group__RSA.html#gacf909918dbe4ca43eda83f947aa64313">wc_RsaPrivateDecryptInline_ex</a>(out, ret, &amp;plain, &amp;key, WC_RSA_OAEP_PAD, WC_HASH_TYPE_SHA, WC_MGF1SHA1, NULL, 0);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="comment">//handle error</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga49c56ab962875a5b91e8a123b9ee7b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49c56ab962875a5b91e8a123b9ee7b1b">&#9670;&nbsp;</a></span>wc_RsaPrivateKeyDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaPrivateKeyDecode </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>inOutIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a DER-formatted RSA private key, extracts the private key and stores it in the given <a class="el" href="structRsaKey.html">RsaKey</a> structure. It also sets the distance parsed in idx. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully parsing the private key from the DER encoded input </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the private key from the input buffer. This may happen if the input private key is not properly formatted according to ASN.1 standards </dd>
<dd>
ASN_RSA_KEY_E Returned if there is an error reading the private key elements of the RSA key input</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>pointer to the buffer containing the DER formatted private key to decode </td></tr>
    <tr><td class="paramname">inOutIdx</td><td>pointer to the index in the buffer at which the key begins (usually 0). As a side effect of this function, inOutIdx will store the distance parsed through the input buffer </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structRsaKey.html">RsaKey</a> structure in which to store the decoded private key </td></tr>
    <tr><td class="paramname">inSz</td><td>size of the input buffer</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> enc;</div><div class="line">word32 idx = 0;</div><div class="line"><span class="keywordtype">int</span> ret = 0;</div><div class="line">byte der[] = { <span class="comment">// initialize with DER-encoded RSA private key };</span></div><div class="line"></div><div class="line"><a class="code" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa">wc_InitRsaKey</a>(&amp;enc, NULL); <span class="comment">// not using heap hint. No custom memory</span></div><div class="line">ret = <a class="code" href="group__RSA.html#ga49c56ab962875a5b91e8a123b9ee7b1b">wc_RsaPrivateKeyDecode</a>(der, &amp;idx, &amp;enc, <span class="keyword">sizeof</span>(der));</div><div class="line"><span class="keywordflow">if</span>( ret != 0 ) {</div><div class="line">    <span class="comment">// error parsing private key </span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#ga054bd3f110ed3024bfe03f35bda1f728" title="This function parses a DER-formatted RSA public key, extracts the public key and stores it in the giv...">wc_RsaPublicKeyDecode</a> </dd>
<dd>
<a class="el" href="group__RSA.html#ga1898e2571ff02a4ba02a7abb7b8066e4" title="This function generates a RSA private key of length size (in bits) and given exponent (e)...">wc_MakeRsaKey</a> </dd></dl>

</div>
</div>
<a id="gaf339effdd51d5eb0eb61fff07dade9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf339effdd51d5eb0eb61fff07dade9b3">&#9670;&nbsp;</a></span>wc_RsaPublicEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaPublicEncrypt </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>outLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWC__RNG.html">WC_RNG</a> *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function encrypts a message from in and stores the result in out. It requires an initialized public key and a random number generator. As a side effect, this function will return the bytes written to out in outLen. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Upon successfully encrypting the input message, returns the number bytes written to out </dd>
<dd>
-1 Returned if there is an error during RSA encryption and hardware acceleration via Cavium is enabled </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input parameters are invalid </dd>
<dd>
RSA_BUFFER_E Returned if the output buffer is too small to store the ciphertext </dd>
<dd>
RNG_FAILURE_E Returned if there is an error generating a random block using the provided RNG structure </dd>
<dd>
MP_INIT_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_READ_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_CMP_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_INVMOD_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_EXPTMOD_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_MOD_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_MUL_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_ADD_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_MULMOD_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_TO_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_MEM May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_ZERO_E May be returned if there is an error in the math library used while encrypting the message</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to a buffer containing the input message to encrypt </td></tr>
    <tr><td class="paramname">inLen</td><td>the length of the message to encrypt </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the output ciphertext </td></tr>
    <tr><td class="paramname">outLen</td><td>the length of the output buffer </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structRsaKey.html">RsaKey</a> structure containing the public key to use for encryption </td></tr>
    <tr><td class="paramname">rng</td><td>The RNG structure with which to generate random block padding</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> pub;</div><div class="line"><span class="keywordtype">int</span> ret = 0;</div><div class="line">byte n[] = { <span class="comment">// initialize with received n component of public key };</span></div><div class="line">byte e[] = { <span class="comment">// initialize with received e component of public key };</span></div><div class="line">byte msg[] = { <span class="comment">// initialize with plaintext of message to encrypt };</span></div><div class="line">byte cipher[256]; <span class="comment">// 256 bytes is large enough to store 2048 bit RSA ciphertext</span></div><div class="line"></div><div class="line"><a class="code" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa">wc_InitRsaKey</a>(&amp;pub, NULL); <span class="comment">// not using heap hint. No custom memory</span></div><div class="line"><a class="code" href="group__RSA.html#ga8e8ce832e128685c2d550e27f3881eeb">wc_RsaPublicKeyDecodeRaw</a>(n, <span class="keyword">sizeof</span>(n), e, <span class="keyword">sizeof</span>(e), &amp;pub);</div><div class="line"><span class="comment">// initialize with received public key parameters</span></div><div class="line">ret = <a class="code" href="group__RSA.html#gaf339effdd51d5eb0eb61fff07dade9b3">wc_RsaPublicEncrypt</a>(msg, <span class="keyword">sizeof</span>(msg), out, <span class="keyword">sizeof</span>(out), &amp;pub, &amp;rng);</div><div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div><div class="line">    <span class="comment">// error encrypting message</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#ga2a3ef7b29bfcfe17b9cc1ec834c0928e" title="This functions provides private RSA decryption. ">wc_RsaPrivateDecrypt</a> </dd></dl>

</div>
</div>
<a id="gad7fb99d485b23378288e5654daf9a4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7fb99d485b23378288e5654daf9a4f1">&#9670;&nbsp;</a></span>wc_RsaPublicEncrypt_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaPublicEncrypt_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>outLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWC__RNG.html">WC_RNG</a> *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mgf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>lableSz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs RSA encrypt while allowing the choice of which padding to use. </p>
<dl class="section return"><dt>Returns</dt><dd>size On successfully encryption the size of the encrypted buffer is returned </dd>
<dd>
RSA_BUFFER_E RSA buffer error, output too small or input too large</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer for encryption </td></tr>
    <tr><td class="paramname">inLen</td><td>length of the buffer to encrypt </td></tr>
    <tr><td class="paramname">out</td><td>encrypted msg created </td></tr>
    <tr><td class="paramname">outLen</td><td>length of buffer available to hold encrypted msg </td></tr>
    <tr><td class="paramname">key</td><td>initialized RSA key struct </td></tr>
    <tr><td class="paramname">rng</td><td>initialized <a class="el" href="structWC__RNG.html">WC_RNG</a> struct </td></tr>
    <tr><td class="paramname">type</td><td>type of padding to use (WC_RSA_OAEP_PAD or WC_RSA_PKCSV15_PAD) </td></tr>
    <tr><td class="paramname">hash</td><td>type of hash to use (choices can be found in <a class="el" href="hash_8h_source.html">hash.h</a>) </td></tr>
    <tr><td class="paramname">mgf</td><td>type of mask generation function to use </td></tr>
    <tr><td class="paramname">label</td><td>an optional label to associate with encrypted message </td></tr>
    <tr><td class="paramname">labelSz</td><td>size of the optional label used</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWC__RNG.html">WC_RNG</a> rng;</div><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> key;</div><div class="line">byte in[] = “I use Turing Machines to ask questions”</div><div class="line">byte out[256];</div><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line">…</div><div class="line"></div><div class="line">ret = <a class="code" href="group__RSA.html#gad7fb99d485b23378288e5654daf9a4f1">wc_RsaPublicEncrypt_ex</a>(in, <span class="keyword">sizeof</span>(in), out, <span class="keyword">sizeof</span>(out), &amp;key, &amp;rng, WC_RSA_OAEP_PAD, WC_HASH_TYPE_SHA, WC_MGF1SHA1, NULL, 0);</div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="comment">//handle error</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#gaf339effdd51d5eb0eb61fff07dade9b3" title="This function encrypts a message from in and stores the result in out. It requires an initialized pub...">wc_RsaPublicEncrypt</a> </dd>
<dd>
<a class="el" href="group__RSA.html#gaa6301321efaabad2792da9bede8a4356" title="This function uses RSA to decrypt a message and gives the option of what padding type. ">wc_RsaPrivateDecrypt_ex</a> </dd></dl>

</div>
</div>
<a id="ga054bd3f110ed3024bfe03f35bda1f728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga054bd3f110ed3024bfe03f35bda1f728">&#9670;&nbsp;</a></span>wc_RsaPublicKeyDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaPublicKeyDecode </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>inOutIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a DER-formatted RSA public key, extracts the public key and stores it in the given <a class="el" href="structRsaKey.html">RsaKey</a> structure. It also sets the distance parsed in idx. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully parsing the public key from the DER encoded input </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the public key from the input buffer. This may happen if the input public key is not properly formatted according to ASN.1 standards </dd>
<dd>
ASN_OBJECT_ID_E Returned if the ASN.1 Object ID does not match that of a RSA public key </dd>
<dd>
ASN_EXPECT_0_E Returned if the input key is not correctly formatted according to ASN.1 standards </dd>
<dd>
ASN_BITSTR_E Returned if the input key is not correctly formatted according to ASN.1 standards </dd>
<dd>
ASN_RSA_KEY_E Returned if there is an error reading the public key elements of the RSA key input</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>pointer to the buffer containing the input DER-encoded RSA public key to decode </td></tr>
    <tr><td class="paramname">inOutIdx</td><td>pointer to the index in the buffer at which the key begins (usually 0). As a side effect of this function, inOutIdx will store the distance parsed through the input buffer </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structRsaKey.html">RsaKey</a> structure in which to store the decoded public key </td></tr>
    <tr><td class="paramname">inSz</td><td>size of the input buffer</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> pub;</div><div class="line">word32 idx = 0;</div><div class="line"><span class="keywordtype">int</span> ret = 0;</div><div class="line">byte der[] = { <span class="comment">// initialize with DER-encoded RSA public key };</span></div><div class="line"></div><div class="line"><a class="code" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa">wc_InitRsaKey</a>(&amp;pub, NULL); <span class="comment">// not using heap hint. No custom memory</span></div><div class="line">ret = <a class="code" href="group__RSA.html#ga054bd3f110ed3024bfe03f35bda1f728">wc_RsaPublicKeyDecode</a>(der, &amp;idx, &amp;pub, <span class="keyword">sizeof</span>(der));</div><div class="line"><span class="keywordflow">if</span>( ret != 0 ) {</div><div class="line">    <span class="comment">// error parsing public key </span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#ga8e8ce832e128685c2d550e27f3881eeb" title="This function decodes the raw elements of an RSA public key, taking in the public modulus (n) and exp...">wc_RsaPublicKeyDecodeRaw</a> </dd></dl>

</div>
</div>
<a id="ga8e8ce832e128685c2d550e27f3881eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e8ce832e128685c2d550e27f3881eeb">&#9670;&nbsp;</a></span>wc_RsaPublicKeyDecodeRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaPublicKeyDecodeRaw </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>nSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>eSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function decodes the raw elements of an RSA public key, taking in the public modulus (n) and exponent (e). It stores these raw elements in the provided <a class="el" href="structRsaKey.html">RsaKey</a> structure, allowing one to use them in the encryption/decryption process. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully decoding the raw elements of the public key into the <a class="el" href="structRsaKey.html">RsaKey</a> structure </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input arguments evaluates to NULL </dd>
<dd>
MP_INIT_E Returned if there is an error initializing an integer for use with the multiple precision integer (<a class="el" href="structmp__int.html">mp_int</a>) library </dd>
<dd>
ASN_GETINT_E Returned if there is an error reading one of the provided RSA key elements, n or e</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>pointer to a buffer containing the raw modulus parameter of the public RSA key </td></tr>
    <tr><td class="paramname">nSz</td><td>size of the buffer containing n </td></tr>
    <tr><td class="paramname">e</td><td>pointer to a buffer containing the raw exponent parameter of the public RSA key </td></tr>
    <tr><td class="paramname">eSz</td><td>size of the buffer containing e </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structRsaKey.html">RsaKey</a> struct to initialize with the provided public key elements</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> pub;</div><div class="line"><span class="keywordtype">int</span> ret = 0;</div><div class="line">byte n[] = { <span class="comment">// initialize with received n component of public key };</span></div><div class="line">byte e[] = { <span class="comment">// initialize with received e component of public key };</span></div><div class="line"></div><div class="line"><a class="code" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa">wc_InitRsaKey</a>(&amp;pub, NULL); <span class="comment">// not using heap hint. No custom memory</span></div><div class="line">ret = <a class="code" href="group__RSA.html#ga8e8ce832e128685c2d550e27f3881eeb">wc_RsaPublicKeyDecodeRaw</a>(n, <span class="keyword">sizeof</span>(n), e, <span class="keyword">sizeof</span>(e), &amp;pub);</div><div class="line"><span class="keywordflow">if</span>( ret != 0 ) {</div><div class="line">    <span class="comment">// error parsing public key elements</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#ga054bd3f110ed3024bfe03f35bda1f728" title="This function parses a DER-formatted RSA public key, extracts the public key and stores it in the giv...">wc_RsaPublicKeyDecode</a> </dd></dl>

</div>
</div>
<a id="gaf16753fea3f44c320af565f9930d5dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf16753fea3f44c320af565f9930d5dc8">&#9670;&nbsp;</a></span>wc_RsaSSL_Sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaSSL_Sign </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>outLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWC__RNG.html">WC_RNG</a> *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signs the provided array with the private key. </p>
<dl class="section return"><dt>Returns</dt><dd>RSA_BUFFER_E: -131, RSA buffer error, output too small or input too large</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be encrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the encrypted data to be stored. </td></tr>
    <tr><td class="paramname">outLen</td><td>The length of out. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for encryption. </td></tr>
    <tr><td class="paramname">RNG</td><td>The RNG struct to use for random number purposes.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code" href="group__RSA.html#gaf16753fea3f44c320af565f9930d5dc8">wc_RsaSSL_Sign</a>(in, inLen, out, <span class="keyword">sizeof</span>(out), &amp;key, &amp;rng);</div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">}</div><div class="line">memset(plain, 0, <span class="keyword">sizeof</span>(plain));</div><div class="line">ret = <a class="code" href="group__RSA.html#gaa60b9072c038124a9f833a7cbd49d052">wc_RsaSSL_Verify</a>(out, ret, plain, <span class="keyword">sizeof</span>(plain), &amp;key);</div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wc_RsaPad </dd></dl>
<p>Set up Montgomery state</p>
<p>Check and reduce input This is needed for calls to MontExp since required value of a &lt; modulus</p>

</div>
</div>
<a id="gaa60b9072c038124a9f833a7cbd49d052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa60b9072c038124a9f833a7cbd49d052">&#9670;&nbsp;</a></span>wc_RsaSSL_Verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaSSL_Verify </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>outLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to verify that the message was signed by key. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Length of text on no error. </dd>
<dd>
MEMORY_E memory exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the decrypted data to be stored. </td></tr>
    <tr><td class="paramname">outLen</td><td>The length of out. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for verification.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code" href="group__RSA.html#gaf16753fea3f44c320af565f9930d5dc8">wc_RsaSSL_Sign</a>(in, inLen, out, <span class="keyword">sizeof</span>(out), &amp;key, &amp;rng);</div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">}</div><div class="line">memset(plain, 0, <span class="keyword">sizeof</span>(plain));</div><div class="line">ret = <a class="code" href="group__RSA.html#gaa60b9072c038124a9f833a7cbd49d052">wc_RsaSSL_Verify</a>(out, ret, plain, <span class="keyword">sizeof</span>(plain), &amp;key);</div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#gaf16753fea3f44c320af565f9930d5dc8" title="Signs the provided array with the private key. ">wc_RsaSSL_Sign</a> </dd></dl>

</div>
</div>
<a id="gab44880f347cd15a53c4e4962f6f779a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab44880f347cd15a53c4e4962f6f779a6">&#9670;&nbsp;</a></span>wc_RsaSSL_VerifyInline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_RsaSSL_VerifyInline </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRsaKey.html">RsaKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to verify that the message was signed by RSA key. The output uses the same byte array as the input. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Length of text. </dd>
<dd>
&lt;0 An error occurred.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>Length of the buffer input. </td></tr>
    <tr><td class="paramname">out</td><td>Pointer to a pointer for decrypted information. </td></tr>
    <tr><td class="paramname">key</td><td><a class="el" href="structRsaKey.html">RsaKey</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structRsaKey.html">RsaKey</a> key;</div><div class="line">RNG rng;</div><div class="line"><span class="keywordtype">int</span> ret = 0;</div><div class="line"><span class="keywordtype">long</span> e = 65537; <span class="comment">// standard value to use for exponent</span></div><div class="line"><a class="code" href="group__RSA.html#gac54dd243045fe8ffb12f63f06a4213fa">wc_InitRsaKey</a>(&amp;key, NULL); <span class="comment">// not using heap hint. No custom memory</span></div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line"><a class="code" href="group__RSA.html#ga1898e2571ff02a4ba02a7abb7b8066e4">wc_MakeRsaKey</a>(&amp;key, 2048, e, &amp;rng);</div><div class="line"></div><div class="line">byte in[] = { <span class="comment">// Initialize with some RSA encrypted information }</span></div><div class="line">byte* out;</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__RSA.html#gab44880f347cd15a53c4e4962f6f779a6">wc_RsaSSL_VerifyInline</a>(in, <span class="keyword">sizeof</span>(in), &amp;out, &amp;key) &lt; 0)</div><div class="line">{</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#gaa60b9072c038124a9f833a7cbd49d052" title="Used to verify that the message was signed by key. ">wc_RsaSSL_Verify</a> </dd>
<dd>
<a class="el" href="group__RSA.html#gaf16753fea3f44c320af565f9930d5dc8" title="Signs the provided array with the private key. ">wc_RsaSSL_Sign</a> </dd></dl>

</div>
</div>
<a id="ga37fffd370cc1635d98ac69b142e91b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fffd370cc1635d98ac69b142e91b67">&#9670;&nbsp;</a></span>wc_SetKeyUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_SetKeyUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCert.html">Cert</a> *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows you to set the key usage using a comma delimited string of tokens. Accepted tokens are: digitalSignature, nonRepudiation, contentCommitment, keyCertSign, cRLSign, dataEncipherment, keyAgreement, keyEncipherment, encipherOnly, decipherOnly. Example: "digitalSignature,nonRepudiation" nonRepudiation and contentCommitment are for the same usage. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returned when either arg is null. </dd>
<dd>
MEMORY_E Returned when there is an error allocating memory. </dd>
<dd>
KEYUSAGE_E Returned if an unrecognized token is entered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Pointer to initialized <a class="el" href="structCert.html">Cert</a> structure. </td></tr>
    <tr><td class="paramname">value</td><td>Comma delimited string of tokens to set usage.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structCert.html">Cert</a> cert;</div><div class="line"><a class="code" href="group__ASN.html#gafb9d58499f02f5d7c83607a4d1b229f5">wc_InitCert</a>(&amp;cert);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__RSA.html#ga37fffd370cc1635d98ac69b142e91b67">wc_SetKeyUsage</a>(&amp;cert, <span class="stringliteral">&quot;cRLSign,keyCertSign&quot;</span>) != 0)</div><div class="line">{</div><div class="line">    <span class="comment">// Handle error</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ASN.html#gafb9d58499f02f5d7c83607a4d1b229f5" title="This function initializes a default cert, with the default options: version = 3 (0x2), serial = 0, sigType = SHA_WITH_RSA, issuer = blank, daysValid = 500, selfSigned = 1 (true) use subject as issuer, subject = blank. ">wc_InitCert</a> </dd>
<dd>
<a class="el" href="group__RSA.html#ga1898e2571ff02a4ba02a7abb7b8066e4" title="This function generates a RSA private key of length size (in bits) and given exponent (e)...">wc_MakeRsaKey</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
