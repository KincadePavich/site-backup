<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>/home/conner/Desktop/WolfSSL_Docs/doxygen/dox_repo/wolfssl/wolfssl/io.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_dfb12bfb545c81f98c26cc500f1dbda8.html">wolfssl</a></li><li class="navelem"><a class="el" href="dir_82794da501e4dededf736909a151513c.html">wolfssl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">io.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="io_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6d6654fe512b6aa06d63667475d56ed7"><td class="memItemLeft" align="right" valign="top"><a id="a6d6654fe512b6aa06d63667475d56ed7"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>SOCKET_T</b></td></tr>
<tr class="separator:a6d6654fe512b6aa06d63667475d56ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae334b73cedf7204187dce3f817576009"><td class="memItemLeft" align="right" valign="top"><a id="ae334b73cedf7204187dce3f817576009"></a>
typedef struct sockaddr&#160;</td><td class="memItemRight" valign="bottom"><b>SOCKADDR</b></td></tr>
<tr class="separator:ae334b73cedf7204187dce3f817576009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23043b1470cd902b71a64d4a1c2b249"><td class="memItemLeft" align="right" valign="top"><a id="ad23043b1470cd902b71a64d4a1c2b249"></a>
typedef struct sockaddr_storage&#160;</td><td class="memItemRight" valign="bottom"><b>SOCKADDR_S</b></td></tr>
<tr class="separator:ad23043b1470cd902b71a64d4a1c2b249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29046dc0232f0e5c70adbc25090d77b8"><td class="memItemLeft" align="right" valign="top"><a id="a29046dc0232f0e5c70adbc25090d77b8"></a>
typedef struct sockaddr_in&#160;</td><td class="memItemRight" valign="bottom"><b>SOCKADDR_IN</b></td></tr>
<tr class="separator:a29046dc0232f0e5c70adbc25090d77b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483104f79f375d7fe3e0f140f05f782b"><td class="memItemLeft" align="right" valign="top"><a id="a483104f79f375d7fe3e0f140f05f782b"></a>
typedef struct sockaddr_in6&#160;</td><td class="memItemRight" valign="bottom"><b>SOCKADDR_IN6</b></td></tr>
<tr class="separator:a483104f79f375d7fe3e0f140f05f782b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00efd0fdd0cb87ebd4106b85293990ed"><td class="memItemLeft" align="right" valign="top"><a id="a00efd0fdd0cb87ebd4106b85293990ed"></a>
typedef struct <a class="el" href="structhostent.html">hostent</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HOSTENT</b></td></tr>
<tr class="separator:a00efd0fdd0cb87ebd4106b85293990ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad217ed5254e232b861c550ab6feac406"><td class="memItemLeft" align="right" valign="top"><a id="ad217ed5254e232b861c550ab6feac406"></a>
typedef struct addrinfo&#160;</td><td class="memItemRight" valign="bottom"><b>ADDRINFO</b></td></tr>
<tr class="separator:ad217ed5254e232b861c550ab6feac406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8905d96a1ff30d8469805d66eea42e19"><td class="memItemLeft" align="right" valign="top"><a id="a8905d96a1ff30d8469805d66eea42e19"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>CallbackIORecv</b>) (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *buf, int sz, void *ctx)</td></tr>
<tr class="separator:a8905d96a1ff30d8469805d66eea42e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7202a3a6c497036e5add55e8629866"><td class="memItemLeft" align="right" valign="top"><a id="abd7202a3a6c497036e5add55e8629866"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>CallbackIOSend</b>) (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *buf, int sz, void *ctx)</td></tr>
<tr class="separator:abd7202a3a6c497036e5add55e8629866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9621200f8b5e32d45e70a00b458877"><td class="memItemLeft" align="right" valign="top"><a id="a0b9621200f8b5e32d45e70a00b458877"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>CallbackGenCookie</b>) (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, unsigned char *buf, int sz, void *ctx)</td></tr>
<tr class="separator:a0b9621200f8b5e32d45e70a00b458877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6508ffaddb580551995e9dbb49d132"><td class="memItemLeft" align="right" valign="top"><a id="aeb6508ffaddb580551995e9dbb49d132"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>CallbackGetPeer</b>) (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *ip, int *ipSz, unsigned short *port, int *fam)</td></tr>
<tr class="separator:aeb6508ffaddb580551995e9dbb49d132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9aa3e5aa2c76860e74d32a7ed9b8bfc"><td class="memItemLeft" align="right" valign="top"><a id="ae9aa3e5aa2c76860e74d32a7ed9b8bfc"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>CallbackSetPeer</b>) (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *ip, int ipSz, unsigned short port, int fam)</td></tr>
<tr class="separator:ae9aa3e5aa2c76860e74d32a7ed9b8bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2793825b7ca411140f868cdbc5ee8592"><td class="memItemLeft" align="right" valign="top"><a id="a2793825b7ca411140f868cdbc5ee8592"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>net_recv</b> (int, void *, int, unsigned int)</td></tr>
<tr class="separator:a2793825b7ca411140f868cdbc5ee8592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39168617ed0b7bb5ad566784806d4c1d"><td class="memItemLeft" align="right" valign="top"><a id="a39168617ed0b7bb5ad566784806d4c1d"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_SetBlockingMode</b> (SOCKET_T sockfd, int non_blocking)</td></tr>
<tr class="separator:a39168617ed0b7bb5ad566784806d4c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6477c8ce8524e41a71d7766c3ae9aec9"><td class="memItemLeft" align="right" valign="top"><a id="a6477c8ce8524e41a71d7766c3ae9aec9"></a>
WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_SetTimeout</b> (int to_sec)</td></tr>
<tr class="separator:a6477c8ce8524e41a71d7766c3ae9aec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab9bc325e116c8bb25e3dc1441903f6"><td class="memItemLeft" align="right" valign="top"><a id="a0ab9bc325e116c8bb25e3dc1441903f6"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_Select</b> (SOCKET_T sockfd, int to_sec)</td></tr>
<tr class="separator:a0ab9bc325e116c8bb25e3dc1441903f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae323c42d1c63c19a29f97dd335a57e39"><td class="memItemLeft" align="right" valign="top"><a id="ae323c42d1c63c19a29f97dd335a57e39"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_TcpConnect</b> (SOCKET_T *sockfd, const char *ip, unsigned short port, int to_sec)</td></tr>
<tr class="separator:ae323c42d1c63c19a29f97dd335a57e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2120561a9765689ec6bec041e7302a30"><td class="memItemLeft" align="right" valign="top"><a id="a2120561a9765689ec6bec041e7302a30"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_Send</b> (SOCKET_T sd, char *buf, int sz, int wrFlags)</td></tr>
<tr class="separator:a2120561a9765689ec6bec041e7302a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35a9a44b8403629a82984b258041996"><td class="memItemLeft" align="right" valign="top"><a id="af35a9a44b8403629a82984b258041996"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_Recv</b> (SOCKET_T sd, char *buf, int sz, int rdFlags)</td></tr>
<tr class="separator:af35a9a44b8403629a82984b258041996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02055ed06a40f0998c0981b348bed628"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#a02055ed06a40f0998c0981b348bed628">EmbedReceive</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *buf, int sz, void *ctx)</td></tr>
<tr class="memdesc:a02055ed06a40f0998c0981b348bed628"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the receive embedded callback.  <a href="#a02055ed06a40f0998c0981b348bed628">More...</a><br /></td></tr>
<tr class="separator:a02055ed06a40f0998c0981b348bed628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af653b3f6ea60177fbef090d07b9f8e47"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#af653b3f6ea60177fbef090d07b9f8e47">EmbedSend</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *buf, int sz, void *ctx)</td></tr>
<tr class="memdesc:af653b3f6ea60177fbef090d07b9f8e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the send embedded callback.  <a href="#af653b3f6ea60177fbef090d07b9f8e47">More...</a><br /></td></tr>
<tr class="separator:af653b3f6ea60177fbef090d07b9f8e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5918ed8171306a8b0ac26d0bdbc7320b"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#a5918ed8171306a8b0ac26d0bdbc7320b">EmbedReceiveFrom</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *buf, int sz, void *)</td></tr>
<tr class="memdesc:a5918ed8171306a8b0ac26d0bdbc7320b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the receive embedded callback.  <a href="#a5918ed8171306a8b0ac26d0bdbc7320b">More...</a><br /></td></tr>
<tr class="separator:a5918ed8171306a8b0ac26d0bdbc7320b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb78edfc45a99a189dfef5a9a890ebe"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#abeb78edfc45a99a189dfef5a9a890ebe">EmbedSendTo</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *buf, int sz, void *ctx)</td></tr>
<tr class="memdesc:abeb78edfc45a99a189dfef5a9a890ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the send embedded callback.  <a href="#abeb78edfc45a99a189dfef5a9a890ebe">More...</a><br /></td></tr>
<tr class="separator:abeb78edfc45a99a189dfef5a9a890ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c99b1155cc0290d951e0a7377c0569d"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#a5c99b1155cc0290d951e0a7377c0569d">EmbedGenerateCookie</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, unsigned char *buf, int sz, void *)</td></tr>
<tr class="memdesc:a5c99b1155cc0290d951e0a7377c0569d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the DTLS Generate <a class="el" href="structCookie.html">Cookie</a> callback.  <a href="#a5c99b1155cc0290d951e0a7377c0569d">More...</a><br /></td></tr>
<tr class="separator:a5c99b1155cc0290d951e0a7377c0569d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9988296d7676236e620f63a82c672185"><td class="memItemLeft" align="right" valign="top"><a id="a9988296d7676236e620f63a82c672185"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>EmbedGetPeer</b> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *ip, int *ipSz, unsigned short *port, int *fam)</td></tr>
<tr class="separator:a9988296d7676236e620f63a82c672185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa333e80a8bb9c468721c0ec6eced3ef0"><td class="memItemLeft" align="right" valign="top"><a id="aa333e80a8bb9c468721c0ec6eced3ef0"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>EmbedSetPeer</b> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *ip, int ipSz, unsigned short port, int fam)</td></tr>
<tr class="separator:aa333e80a8bb9c468721c0ec6eced3ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50bc47cb2f3be0a5f17ab56abe9ae01"><td class="memItemLeft" align="right" valign="top"><a id="aa50bc47cb2f3be0a5f17ab56abe9ae01"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_HttpBuildRequestOcsp</b> (const char *domainName, const char *path, int ocspReqSz, unsigned char *buf, int bufSize)</td></tr>
<tr class="separator:aa50bc47cb2f3be0a5f17ab56abe9ae01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613a504896ac5479a5c9bc30d55e198b"><td class="memItemLeft" align="right" valign="top"><a id="a613a504896ac5479a5c9bc30d55e198b"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_HttpProcessResponseOcsp</b> (int sfd, unsigned char **respBuf, unsigned char *httpBuf, int httpBufSz, void *heap)</td></tr>
<tr class="separator:a613a504896ac5479a5c9bc30d55e198b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef47519897f9cfb5a7a2bf4d8baa32c9"><td class="memItemLeft" align="right" valign="top"><a id="aef47519897f9cfb5a7a2bf4d8baa32c9"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>EmbedOcspLookup</b> (void *, const char *, int, unsigned char *, int, unsigned char **)</td></tr>
<tr class="separator:aef47519897f9cfb5a7a2bf4d8baa32c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbda2e5136770f287649dbc4e7ef65e"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#a9fbda2e5136770f287649dbc4e7ef65e">EmbedOcspRespFree</a> (void *, unsigned char *)</td></tr>
<tr class="memdesc:a9fbda2e5136770f287649dbc4e7ef65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees the response buffer.  <a href="#a9fbda2e5136770f287649dbc4e7ef65e">More...</a><br /></td></tr>
<tr class="separator:a9fbda2e5136770f287649dbc4e7ef65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee158f195f44dc7fcb9c9833dd02214"><td class="memItemLeft" align="right" valign="top"><a id="a9ee158f195f44dc7fcb9c9833dd02214"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_HttpBuildRequestCrl</b> (const char *url, int urlSz, const char *domainName, unsigned char *buf, int bufSize)</td></tr>
<tr class="separator:a9ee158f195f44dc7fcb9c9833dd02214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d19d71b6f8d943868d63f449091650"><td class="memItemLeft" align="right" valign="top"><a id="ac5d19d71b6f8d943868d63f449091650"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_HttpProcessResponseCrl</b> (<a class="el" href="structWOLFSSL__CRL.html">WOLFSSL_CRL</a> *crl, int sfd, unsigned char *httpBuf, int httpBufSz)</td></tr>
<tr class="separator:ac5d19d71b6f8d943868d63f449091650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343ed1c61be2a7b1061b87633a03aa45"><td class="memItemLeft" align="right" valign="top"><a id="a343ed1c61be2a7b1061b87633a03aa45"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>EmbedCrlLookup</b> (<a class="el" href="structWOLFSSL__CRL.html">WOLFSSL_CRL</a> *crl, const char *url, int urlSz)</td></tr>
<tr class="separator:a343ed1c61be2a7b1061b87633a03aa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fd1b7a747fb9ea34bc0d7a022c2c4a"><td class="memItemLeft" align="right" valign="top"><a id="ad3fd1b7a747fb9ea34bc0d7a022c2c4a"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_DecodeUrl</b> (const char *url, int urlSz, char *outName, char *outPath, unsigned short *outPort)</td></tr>
<tr class="separator:ad3fd1b7a747fb9ea34bc0d7a022c2c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e3fc3ded832bcf9a812752baf8d091"><td class="memItemLeft" align="right" valign="top"><a id="a31e3fc3ded832bcf9a812752baf8d091"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_HttpBuildRequest</b> (const char *reqType, const char *domainName, const char *path, int pathLen, int reqSz, const char *contentType, unsigned char *buf, int bufSize)</td></tr>
<tr class="separator:a31e3fc3ded832bcf9a812752baf8d091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47036d861b0eb37e7075f6c194013c8c"><td class="memItemLeft" align="right" valign="top"><a id="a47036d861b0eb37e7075f6c194013c8c"></a>
WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>wolfIO_HttpProcessResponse</b> (int sfd, const char *appStr, unsigned char **respBuf, unsigned char *httpBuf, int httpBufSz, int dynType, void *heap)</td></tr>
<tr class="separator:a47036d861b0eb37e7075f6c194013c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60b951edb103c2c16ec6ce19ba37ba8"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#ae60b951edb103c2c16ec6ce19ba37ba8">wolfSSL_SetIORecv</a> (<a class="el" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a> *, CallbackIORecv)</td></tr>
<tr class="memdesc:ae60b951edb103c2c16ec6ce19ba37ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers a receive callback for <a class="el" href="namespacewolfSSL.html">wolfSSL</a> to get input data. By default, <a class="el" href="namespacewolfSSL.html">wolfSSL</a> uses <a class="el" href="io_8h.html#a02055ed06a40f0998c0981b348bed628" title="This function is the receive embedded callback. ">EmbedReceive()</a> as the callback which uses the system’s TCP recv() function. The user can register a function to get input from memory, some other network module, or from anywhere. Please see the <a class="el" href="io_8h.html#a02055ed06a40f0998c0981b348bed628" title="This function is the receive embedded callback. ">EmbedReceive()</a> function in src/io.c as a guide for how the function should work and for error codes. In particular, IO_ERR_WANT_READ should be returned for non blocking receive when no data is ready.  <a href="#ae60b951edb103c2c16ec6ce19ba37ba8">More...</a><br /></td></tr>
<tr class="separator:ae60b951edb103c2c16ec6ce19ba37ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d5a2361c89c7cfaa159c6723479c09"><td class="memItemLeft" align="right" valign="top"><a id="a14d5a2361c89c7cfaa159c6723479c09"></a>
WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>wolfSSL_SetIOSend</b> (<a class="el" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a> *, CallbackIOSend)</td></tr>
<tr class="separator:a14d5a2361c89c7cfaa159c6723479c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05215fdd13f28d0cce4e2e2020dd36a3"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#a05215fdd13f28d0cce4e2e2020dd36a3">wolfSSL_SetIOReadCtx</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, void *ctx)</td></tr>
<tr class="memdesc:a05215fdd13f28d0cce4e2e2020dd36a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers a context for the SSL session’s receive callback function. By default, <a class="el" href="namespacewolfSSL.html">wolfSSL</a> sets the file descriptor passed to wolfSSL_set_fd() as the context when <a class="el" href="namespacewolfSSL.html">wolfSSL</a> is using the system’s TCP library. If you’ve registered your own receive callback you may want to set a specific context for the session. For example, if you’re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers.  <a href="#a05215fdd13f28d0cce4e2e2020dd36a3">More...</a><br /></td></tr>
<tr class="separator:a05215fdd13f28d0cce4e2e2020dd36a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cd261cda84bdb604d710744cc65d83"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#a59cd261cda84bdb604d710744cc65d83">wolfSSL_SetIOWriteCtx</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, void *ctx)</td></tr>
<tr class="memdesc:a59cd261cda84bdb604d710744cc65d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers a context for the SSL session’s send callback function. By default, <a class="el" href="namespacewolfSSL.html">wolfSSL</a> sets the file descriptor passed to wolfSSL_set_fd() as the context when <a class="el" href="namespacewolfSSL.html">wolfSSL</a> is using the system’s TCP library. If you’ve registered your own send callback you may want to set a specific context for the session. For example, if you’re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers.  <a href="#a59cd261cda84bdb604d710744cc65d83">More...</a><br /></td></tr>
<tr class="separator:a59cd261cda84bdb604d710744cc65d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82af1fa9fbc39f227c6de20de98c7c7a"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#a82af1fa9fbc39f227c6de20de98c7c7a">wolfSSL_GetIOReadCtx</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl)</td></tr>
<tr class="memdesc:a82af1fa9fbc39f227c6de20de98c7c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the IOCB_ReadCtx member of the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> struct.  <a href="#a82af1fa9fbc39f227c6de20de98c7c7a">More...</a><br /></td></tr>
<tr class="separator:a82af1fa9fbc39f227c6de20de98c7c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac556a07d2311ebd30fa3f4ea66a7165c"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#ac556a07d2311ebd30fa3f4ea66a7165c">wolfSSL_GetIOWriteCtx</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl)</td></tr>
<tr class="memdesc:ac556a07d2311ebd30fa3f4ea66a7165c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the IOCB_WriteCtx member of the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure.  <a href="#ac556a07d2311ebd30fa3f4ea66a7165c">More...</a><br /></td></tr>
<tr class="separator:ac556a07d2311ebd30fa3f4ea66a7165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630457bd1121fc9b6aca55c0657b7f55"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#a630457bd1121fc9b6aca55c0657b7f55">wolfSSL_SetIOReadFlags</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, int flags)</td></tr>
<tr class="memdesc:a630457bd1121fc9b6aca55c0657b7f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the flags for the receive callback to use for the given SSL session. The receive callback could be either the default <a class="el" href="namespacewolfSSL.html">wolfSSL</a> EmbedReceive callback, or a custom callback specified by the user (see wolfSSL_SetIORecv). The default flag value is set internally by <a class="el" href="namespacewolfSSL.html">wolfSSL</a> to the value of 0. The default <a class="el" href="namespacewolfSSL.html">wolfSSL</a> receive callback uses the recv() function to receive data from the socket. From the recv() man page: “The flags argument to a recv() function is formed by or'ing one or more of the values: MSG_OOB process out-of-band data, MSG_PEEK peek at incoming message, MSG_WAITALL wait for full request or error. The MSG_OOB flag requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus this flag cannot be used with such protocols. The MSG_PEEK flag causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data. The MSG_WAITALL flag requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if a signal is caught, an error or disconnect occurs, or the next data to be received is of a different type than that returned.”  <a href="#a630457bd1121fc9b6aca55c0657b7f55">More...</a><br /></td></tr>
<tr class="separator:a630457bd1121fc9b6aca55c0657b7f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12cb9a1963b8dc9208ab1387bf67294"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#ab12cb9a1963b8dc9208ab1387bf67294">wolfSSL_SetIOWriteFlags</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, int flags)</td></tr>
<tr class="memdesc:ab12cb9a1963b8dc9208ab1387bf67294"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the flags for the send callback to use for the given SSL session. The send callback could be either the default <a class="el" href="namespacewolfSSL.html">wolfSSL</a> EmbedSend callback, or a custom callback specified by the user (see wolfSSL_SetIOSend). The default flag value is set internally by <a class="el" href="namespacewolfSSL.html">wolfSSL</a> to the value of 0. The default <a class="el" href="namespacewolfSSL.html">wolfSSL</a> send callback uses the send() function to send data from the socket. From the send() man page: “The flags parameter may include one or more of the following: #define MSG_OOB 0x1 /* process out-of-band data, #define MSG_DONTROUTE 0x4 /* bypass routing, use direct interface. The flag MSG_OOB is used to send <code>out-of-band'' data on sockets that support this notion (e.g. SOCK_STREAM); the underlying protocol must also support</code>out-of-band'' data. MSG_DONTROUTE is usually used only by diagnostic or routing programs.”  <a href="#ab12cb9a1963b8dc9208ab1387bf67294">More...</a><br /></td></tr>
<tr class="separator:ab12cb9a1963b8dc9208ab1387bf67294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1140c559355606214d1de33c05199f60"><td class="memItemLeft" align="right" valign="top"><a id="a1140c559355606214d1de33c05199f60"></a>
WOLFSSL_LOCAL int&#160;</td><td class="memItemRight" valign="bottom"><b>NetX_Receive</b> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *buf, int sz, void *ctx)</td></tr>
<tr class="separator:a1140c559355606214d1de33c05199f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0840accce8efa3abd18b37a4af571f0f"><td class="memItemLeft" align="right" valign="top"><a id="a0840accce8efa3abd18b37a4af571f0f"></a>
WOLFSSL_LOCAL int&#160;</td><td class="memItemRight" valign="bottom"><b>NetX_Send</b> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, char *buf, int sz, void *ctx)</td></tr>
<tr class="separator:a0840accce8efa3abd18b37a4af571f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1103448119a1f924222980d9f12789ad"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#a1103448119a1f924222980d9f12789ad">wolfSSL_SetIO_NetX</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, NX_TCP_SOCKET *nxsocket, ULONG waitoption)</td></tr>
<tr class="memdesc:a1103448119a1f924222980d9f12789ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the nxSocket and nxWait members of the nxCtx struct within the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure.  <a href="#a1103448119a1f924222980d9f12789ad">More...</a><br /></td></tr>
<tr class="separator:a1103448119a1f924222980d9f12789ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa1587e8fa83df93d25d420d1cb0726"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#aafa1587e8fa83df93d25d420d1cb0726">wolfSSL_CTX_SetGenCookie</a> (<a class="el" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a> *, CallbackGenCookie)</td></tr>
<tr class="memdesc:aafa1587e8fa83df93d25d420d1cb0726"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the callback for the CBIOCookie member of the <a class="el" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a> structure. The CallbackGenCookie type is a function pointer and has the signature: int (<em>CallbackGenCookie)(<a class="el" href="structWOLFSSL.html">WOLFSSL</a></em> ssl, unsigned char* buf, int sz, void* ctx);.  <a href="#aafa1587e8fa83df93d25d420d1cb0726">More...</a><br /></td></tr>
<tr class="separator:aafa1587e8fa83df93d25d420d1cb0726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558260705e68ae29275be141b1e38015"><td class="memItemLeft" align="right" valign="top"><a id="a558260705e68ae29275be141b1e38015"></a>
WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>wolfSSL_SetCookieCtx</b> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl, void *ctx)</td></tr>
<tr class="separator:a558260705e68ae29275be141b1e38015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73b375a68c56f946ebcafdd62bbb8ce"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_8h.html#ac73b375a68c56f946ebcafdd62bbb8ce">wolfSSL_GetCookieCtx</a> (<a class="el" href="structWOLFSSL.html">WOLFSSL</a> *ssl)</td></tr>
<tr class="memdesc:ac73b375a68c56f946ebcafdd62bbb8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the IOCB_CookieCtx member of the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure.  <a href="#ac73b375a68c56f946ebcafdd62bbb8ce">More...</a><br /></td></tr>
<tr class="separator:ac73b375a68c56f946ebcafdd62bbb8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d6cb92785de20ad3fe2d3272e1b97b"><td class="memItemLeft" align="right" valign="top"><a id="a14d6cb92785de20ad3fe2d3272e1b97b"></a>
WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>wolfSSL_CTX_SetIOGetPeer</b> (<a class="el" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a> *, CallbackGetPeer)</td></tr>
<tr class="separator:a14d6cb92785de20ad3fe2d3272e1b97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56835963d88ec76805e4fce62f4b9714"><td class="memItemLeft" align="right" valign="top"><a id="a56835963d88ec76805e4fce62f4b9714"></a>
WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>wolfSSL_CTX_SetIOSetPeer</b> (<a class="el" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a> *, CallbackSetPeer)</td></tr>
<tr class="separator:a56835963d88ec76805e4fce62f4b9714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aaa53ca0b650dfd85c4f59fa156f7a2cc"><td class="memItemLeft" align="right" valign="top"><a id="aaa53ca0b650dfd85c4f59fa156f7a2cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C</b></td></tr>
<tr class="separator:aaa53ca0b650dfd85c4f59fa156f7a2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5c99b1155cc0290d951e0a7377c0569d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c99b1155cc0290d951e0a7377c0569d">&#9670;&nbsp;</a></span>EmbedGenerateCookie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int EmbedGenerateCookie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the DTLS Generate <a class="el" href="structCookie.html">Cookie</a> callback. </p>
<dl class="section return"><dt>Returns</dt><dd>Success This function returns the number of bytes copied into the buffer. </dd>
<dd>
GEN_COOKIE_E returned if the getpeername failed in EmbedGenerateCookie.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure, created using wolfSSL_new(). </td></tr>
    <tr><td class="paramname">buf</td><td>byte pointer representing the buffer. It is the destination from XMEMCPY(). </td></tr>
    <tr><td class="paramname">sz</td><td>the size of the buffer. </td></tr>
    <tr><td class="paramname">ctx</td><td>a void pointer to user registered context.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a>* ctx = wolfSSL_CTX_new( method );</div><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = wolfSSL_new(ctx);</div><div class="line">byte <a class="code" href="structWOLFSSL__BUFFER__INFO.html">buffer</a>[BUFFER_SIZE];</div><div class="line"><span class="keywordtype">int</span> sz = <span class="keyword">sizeof</span>(<a class="code" href="structWOLFSSL__BUFFER__INFO.html">buffer</a>)/<span class="keyword">sizeof</span>(byte);</div><div class="line"><span class="keywordtype">void</span>* ctx;</div><div class="line">…</div><div class="line"><span class="keywordtype">int</span> ret = <a class="code" href="io_8h.html#a5c99b1155cc0290d951e0a7377c0569d">EmbedGenerateCookie</a>(ssl, <a class="code" href="structWOLFSSL__BUFFER__INFO.html">buffer</a>, sz, ctx);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(ret &gt; 0){</div><div class="line">    <span class="comment">// EmbedGenerateCookie code block for success</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SHA.html#ga26d2f9f97d39ef2e2454c2da4cec957f" title="Convenience function, handles all the hashing and places the result into hash. ">wc_ShaHash</a> </dd>
<dd>
<a class="el" href="io_8h.html#a5c99b1155cc0290d951e0a7377c0569d" title="This function is the DTLS Generate Cookie callback. ">EmbedGenerateCookie</a> </dd>
<dd>
XMEMCPY </dd>
<dd>
XMEMSET </dd></dl>

</div>
</div>
<a id="a9fbda2e5136770f287649dbc4e7ef65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbda2e5136770f287649dbc4e7ef65e">&#9670;&nbsp;</a></span>EmbedOcspRespFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void EmbedOcspRespFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees the response buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a void pointer to heap hint. </td></tr>
    <tr><td class="paramname">resp</td><td>a byte pointer representing the response.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* ctx;</div><div class="line">byte* resp; <span class="comment">// Response buffer.</span></div><div class="line">…</div><div class="line"><a class="code" href="io_8h.html#a9fbda2e5136770f287649dbc4e7ef65e">EmbedOcspRespFree</a>(ctx, resp);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Memory.html#gabd0f22726220c09d6fe995cca2ab8e1c" title="This is not actually a function, but rather a preprocessor macro, which allows the user to substitute...">XFREE</a> </dd></dl>

</div>
</div>
<a id="a02055ed06a40f0998c0981b348bed628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02055ed06a40f0998c0981b348bed628">&#9670;&nbsp;</a></span>EmbedReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int EmbedReceive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the receive embedded callback. </p>
<dl class="section return"><dt>Returns</dt><dd>Success This function returns the number of bytes read. </dd>
<dd>
WOLFSSL_CBIO_ERR_WANT_READ returned with a “Would block” message if the last error was SOCKET_EWOULDBLCOK or SOCKET_EAGAIN. </dd>
<dd>
WOLFSSL_CBIO_ERR_TIMEOUT returned with a “Socket timeout” message. </dd>
<dd>
WOLFSSL_CBIO_ERR_CONN_RST returned with a “Connection reset” message if the last error was SOCKET_ECONNRESET. </dd>
<dd>
WOLFSSL_CBIO_ERR_ISR returned with a “Socket interrupted” message if the last error was SOCKET_EINTR. </dd>
<dd>
WOLFSSL_CBIO_ERR_WANT_READ returned with a “Connection refused” messag if the last error was SOCKET_ECONNREFUSED. </dd>
<dd>
WOLFSSL_CBIO_ERR_CONN_CLOSE returned with a “Connection aborted” message if the last error was SOCKET_ECONNABORTED. </dd>
<dd>
WOLFSSL_CBIO_ERR_GENERAL returned with a “General error” message if the last error was not specified.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure, created using wolfSSL_new(). </td></tr>
    <tr><td class="paramname">buf</td><td>a char pointer representation of the buffer. </td></tr>
    <tr><td class="paramname">sz</td><td>the size of the buffer. </td></tr>
    <tr><td class="paramname">ctx</td><td>a void pointer to user registered context. In the default case the ctx is a socket descriptor pointer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a>* ctx = wolfSSL_CTX_new( protocol method );</div><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = wolfSSL_new(ctx);</div><div class="line"><span class="keywordtype">char</span>* buf;</div><div class="line"><span class="keywordtype">int</span> sz;</div><div class="line"><span class="keywordtype">void</span>* ctx;</div><div class="line"><span class="keywordtype">int</span> bytesRead = <a class="code" href="io_8h.html#a02055ed06a40f0998c0981b348bed628">EmbedReceive</a>(ssl, buf, sz, ctx);</div><div class="line"><span class="keywordflow">if</span>(bytesRead &lt;= 0){</div><div class="line">    <span class="comment">// There were no bytes read. Failure case.</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_dtls_get_current_timeout </dd>
<dd>
TranslateReturnCode </dd>
<dd>
RECV_FUNCTION </dd></dl>

</div>
</div>
<a id="a5918ed8171306a8b0ac26d0bdbc7320b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5918ed8171306a8b0ac26d0bdbc7320b">&#9670;&nbsp;</a></span>EmbedReceiveFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int EmbedReceiveFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the receive embedded callback. </p>
<dl class="section return"><dt>Returns</dt><dd>Success This function returns the nb bytes read if the execution was successful. </dd>
<dd>
WOLFSSL_CBIO_ERR_WANT_READ if the connection refused or if a ‘would block’ error was thrown in the function. </dd>
<dd>
WOLFSSL_CBIO_ERR_TIMEOUT returned if the socket timed out. </dd>
<dd>
WOLFSSL_CBIO_ERR_CONN_RST returned if the connection reset. </dd>
<dd>
WOLFSSL_CBIO_ERR_ISR returned if the socket was interrupted. </dd>
<dd>
WOLFSSL_CBIO_ERR_GENERAL returned if there was a general error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure, created using wolfSSL_new(). </td></tr>
    <tr><td class="paramname">buf</td><td>a constant char pointer to the buffer. </td></tr>
    <tr><td class="paramname">sz</td><td>an int type representing the size of the buffer. </td></tr>
    <tr><td class="paramname">ctx</td><td>a void pointer to the <a class="el" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a> context.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a>* ctx = wolfSSL_CTX_new( protocol method );</div><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = WOLFSSL_new(ctx);</div><div class="line"><span class="keywordtype">char</span>* buf;</div><div class="line"><span class="keywordtype">int</span> sz = <span class="keyword">sizeof</span>(buf)/<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>);</div><div class="line">(<span class="keywordtype">void</span>*)ctx;</div><div class="line">…</div><div class="line"><span class="keywordtype">int</span> nb = <a class="code" href="io_8h.html#a5918ed8171306a8b0ac26d0bdbc7320b">EmbedReceiveFrom</a>(ssl, buf, sz, ctx);</div><div class="line"><span class="keywordflow">if</span>(nb &gt; 0){</div><div class="line">    <span class="comment">// nb is the number of bytes written and is positive</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>TranslateReturnCode </dd>
<dd>
RECVFROM_FUNCTION </dd>
<dd>
Setsockopt </dd></dl>

</div>
</div>
<a id="af653b3f6ea60177fbef090d07b9f8e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af653b3f6ea60177fbef090d07b9f8e47">&#9670;&nbsp;</a></span>EmbedSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int EmbedSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the send embedded callback. </p>
<dl class="section return"><dt>Returns</dt><dd>Success This function returns the number of bytes sent. </dd>
<dd>
WOLFSSL_CBIO_ERR_WANT_WRITE returned with a “Would block” message if the last error was SOCKET_EWOULDBLOCK or SOCKET_EAGAIN. </dd>
<dd>
WOLFSSL_CBIO_ERR_CONN_RST returned with a “Connection reset” message if the last error was SOCKET_ECONNRESET. </dd>
<dd>
WOLFSSL_CBIO_ERR_ISR returned with a “Socket interrupted” message if the last error was SOCKET_EINTR. </dd>
<dd>
WOLFSSL_CBIO_ERR_CONN_CLOSE returned with a “Socket EPIPE” message if the last error was SOCKET_EPIPE. </dd>
<dd>
WOLFSSL_CBIO_ERR_GENERAL returned with a “General error” message if the last error was not specified.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure, created using wolfSSL_new(). </td></tr>
    <tr><td class="paramname">buf</td><td>a char pointer representing the buffer. </td></tr>
    <tr><td class="paramname">sz</td><td>the size of the buffer. </td></tr>
    <tr><td class="paramname">ctx</td><td>a void pointer to user registered context.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = wolfSSL_new(ctx);</div><div class="line"><span class="keywordtype">char</span>* buf;</div><div class="line"><span class="keywordtype">int</span> sz;</div><div class="line"><span class="keywordtype">void</span>* ctx;  </div><div class="line"><span class="keywordtype">int</span> dSent = <a class="code" href="io_8h.html#af653b3f6ea60177fbef090d07b9f8e47">EmbedSend</a>(ssl, buf, sz, ctx);</div><div class="line"><span class="keywordflow">if</span>(dSent &lt;= 0){</div><div class="line">    <span class="comment">// No byes sent. Failure case.</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>TranslateReturnCode </dd>
<dd>
SEND_FUNCTION </dd>
<dd>
LastError </dd>
<dd>
InitSSL_Ctx </dd>
<dd>
LastError </dd></dl>

</div>
</div>
<a id="abeb78edfc45a99a189dfef5a9a890ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb78edfc45a99a189dfef5a9a890ebe">&#9670;&nbsp;</a></span>EmbedSendTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int EmbedSendTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the send embedded callback. </p>
<dl class="section return"><dt>Returns</dt><dd>Success This function returns the number of bytes sent. </dd>
<dd>
WOLFSSL_CBIO_ERR_WANT_WRITE returned with a “Would Block” message if the last error was either SOCKET_EWOULDBLOCK or SOCKET_EAGAIN error. </dd>
<dd>
WOLFSSL_CBIO_ERR_CONN_RST returned with a “Connection reset” message if the last error was SOCKET_ECONNRESET. </dd>
<dd>
WOLFSSL_CBIO_ERR_ISR returned with a “Socket interrupted” message if the last error was SOCKET_EINTR. </dd>
<dd>
WOLFSSL_CBIO_ERR_CONN_CLOSE returned with a “Socket EPIPE” message if the last error was WOLFSSL_CBIO_ERR_CONN_CLOSE. </dd>
<dd>
WOLFSSL_CBIO_ERR_GENERAL returned with a “General error” message if the last error was not specified.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure, created using wolfSSL_new(). </td></tr>
    <tr><td class="paramname">buf</td><td>a char pointer representing the buffer. </td></tr>
    <tr><td class="paramname">sz</td><td>the size of the buffer. </td></tr>
    <tr><td class="paramname">ctx</td><td>a void pointer to the user registered context. The default case is a <a class="el" href="structWOLFSSL__DTLS__CTX.html">WOLFSSL_DTLS_CTX</a> sructure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl;</div><div class="line">…</div><div class="line"><span class="keywordtype">char</span>* buf;</div><div class="line"><span class="keywordtype">int</span> sz;</div><div class="line"><span class="keywordtype">void</span>* ctx;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> sEmbed = EmbedSendto(ssl, buf, sz, ctx);</div><div class="line"><span class="keywordflow">if</span>(sEmbed &lt;= 0){</div><div class="line">    <span class="comment">// No bytes sent. Failure case.</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>LastError </dd>
<dd>
<a class="el" href="io_8h.html#af653b3f6ea60177fbef090d07b9f8e47" title="This function is the send embedded callback. ">EmbedSend</a> </dd>
<dd>
<a class="el" href="io_8h.html#a02055ed06a40f0998c0981b348bed628" title="This function is the receive embedded callback. ">EmbedReceive</a> </dd></dl>

</div>
</div>
<a id="aafa1587e8fa83df93d25d420d1cb0726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa1587e8fa83df93d25d420d1cb0726">&#9670;&nbsp;</a></span>wolfSSL_CTX_SetGenCookie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wolfSSL_CTX_SetGenCookie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackGenCookie&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the callback for the CBIOCookie member of the <a class="el" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a> structure. The CallbackGenCookie type is a function pointer and has the signature: int (<em>CallbackGenCookie)(<a class="el" href="structWOLFSSL.html">WOLFSSL</a></em> ssl, unsigned char* buf, int sz, void* ctx);. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure, created using wolfSSL_new(). </td></tr>
    <tr><td class="paramname">cb</td><td>a CallbackGenCookie type function pointer with the signature of CallbackGenCookie.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a>* ctx = wolfSSL_CTX_new( method );</div><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = wolfSSL_new(ctx);</div><div class="line">…</div><div class="line"><span class="keywordtype">int</span> SetGenCookieCB(<a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">int</span> sz, <span class="keywordtype">void</span>* ctx){</div><div class="line"><span class="comment">// Callback function body.</span></div><div class="line">}</div><div class="line">…</div><div class="line"><a class="code" href="io_8h.html#aafa1587e8fa83df93d25d420d1cb0726">wolfSSL_CTX_SetGenCookie</a>(ssl-&gt;ctx, SetGenCookieCB);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>CallbackGenCookie </dd></dl>

</div>
</div>
<a id="ac73b375a68c56f946ebcafdd62bbb8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73b375a68c56f946ebcafdd62bbb8ce">&#9670;&nbsp;</a></span>wolfSSL_GetCookieCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void* wolfSSL_GetCookieCtx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the IOCB_CookieCtx member of the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer The function returns a void pointer value stored in the IOCB_CookieCtx. </dd>
<dd>
NULL if the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> struct is NULL</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure, created using wolfSSL_new().</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a>* ctx = wolfSSL_CTX_new( method );</div><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = wolfSSL_new(ctx);</div><div class="line"><span class="keywordtype">void</span>* cookie;</div><div class="line">...</div><div class="line">cookie = <a class="code" href="io_8h.html#ac73b375a68c56f946ebcafdd62bbb8ce">wolfSSL_GetCookieCtx</a>(ssl);</div><div class="line"><span class="keywordflow">if</span>(cookie != NULL){</div><div class="line"><span class="comment">// You have the cookie</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_SetCookieCtx </dd>
<dd>
<a class="el" href="io_8h.html#aafa1587e8fa83df93d25d420d1cb0726" title="This function sets the callback for the CBIOCookie member of the WOLFSSL_CTX structure. The CallbackGenCookie type is a function pointer and has the signature: int (CallbackGenCookie)(WOLFSSL ssl, unsigned char* buf, int sz, void* ctx);. ">wolfSSL_CTX_SetGenCookie</a> </dd></dl>

</div>
</div>
<a id="a82af1fa9fbc39f227c6de20de98c7c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82af1fa9fbc39f227c6de20de98c7c7a">&#9670;&nbsp;</a></span>wolfSSL_GetIOReadCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void* wolfSSL_GetIOReadCtx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the IOCB_ReadCtx member of the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> struct. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer This function returns a void pointer to the IOCB_ReadCtx member of the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure. </dd>
<dd>
NULL returned if the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> struct is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure, created using wolfSSL_new().</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = wolfSSL_new(ctx);</div><div class="line"><span class="keywordtype">void</span>* ioRead;</div><div class="line">...</div><div class="line">ioRead = <a class="code" href="io_8h.html#a82af1fa9fbc39f227c6de20de98c7c7a">wolfSSL_GetIOReadCtx</a>(ssl);</div><div class="line"><span class="keywordflow">if</span>(ioRead == NULL){</div><div class="line">    <span class="comment">// Failure case. The ssl object was NULL.</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="io_8h.html#ac556a07d2311ebd30fa3f4ea66a7165c" title="This function returns the IOCB_WriteCtx member of the WOLFSSL structure. ">wolfSSL_GetIOWriteCtx</a> </dd>
<dd>
<a class="el" href="io_8h.html#a630457bd1121fc9b6aca55c0657b7f55" title="This function sets the flags for the receive callback to use for the given SSL session. The receive callback could be either the default wolfSSL EmbedReceive callback, or a custom callback specified by the user (see wolfSSL_SetIORecv). The default flag value is set internally by wolfSSL to the value of 0. The default wolfSSL receive callback uses the recv() function to receive data from the socket. From the recv() man page: “The flags argument to a recv() function is formed by or&#39;ing one or more of the values: MSG_OOB process out-of-band data, MSG_PEEK peek at incoming message, MSG_WAITALL wait for full request or error. The MSG_OOB flag requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus this flag cannot be used with such protocols. The MSG_PEEK flag causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data. The MSG_WAITALL flag requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if a signal is caught, an error or disconnect occurs, or the next data to be received is of a different type than that returned.” ">wolfSSL_SetIOReadFlags</a> </dd>
<dd>
<a class="el" href="io_8h.html#a59cd261cda84bdb604d710744cc65d83" title="This function registers a context for the SSL session’s send callback function. By default...">wolfSSL_SetIOWriteCtx</a> </dd>
<dd>
<a class="el" href="io_8h.html#a05215fdd13f28d0cce4e2e2020dd36a3" title="This function registers a context for the SSL session’s receive callback function. By default, wolfSSL sets the file descriptor passed to wolfSSL_set_fd() as the context when wolfSSL is using the system’s TCP library. If you’ve registered your own receive callback you may want to set a specific context for the session. For example, if you’re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers. ">wolfSSL_SetIOReadCtx</a> </dd>
<dd>
wolfSSL_SetIOSend </dd></dl>

</div>
</div>
<a id="ac556a07d2311ebd30fa3f4ea66a7165c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac556a07d2311ebd30fa3f4ea66a7165c">&#9670;&nbsp;</a></span>wolfSSL_GetIOWriteCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void* wolfSSL_GetIOWriteCtx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the IOCB_WriteCtx member of the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer This function returns a void pointer to the IOCB_WriteCtx member of the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure. </dd>
<dd>
NULL returned if the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> struct is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure, created using wolfSSL_new().</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl;</div><div class="line"><span class="keywordtype">void</span>* ioWrite;</div><div class="line">...</div><div class="line">ioWrite = <a class="code" href="io_8h.html#ac556a07d2311ebd30fa3f4ea66a7165c">wolfSSL_GetIOWriteCtx</a>(ssl);</div><div class="line"><span class="keywordflow">if</span>(ioWrite == NULL){</div><div class="line">    <span class="comment">// The funciton returned NULL.</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="io_8h.html#a82af1fa9fbc39f227c6de20de98c7c7a" title="This function returns the IOCB_ReadCtx member of the WOLFSSL struct. ">wolfSSL_GetIOReadCtx</a> </dd>
<dd>
<a class="el" href="io_8h.html#a59cd261cda84bdb604d710744cc65d83" title="This function registers a context for the SSL session’s send callback function. By default...">wolfSSL_SetIOWriteCtx</a> </dd>
<dd>
<a class="el" href="io_8h.html#a05215fdd13f28d0cce4e2e2020dd36a3" title="This function registers a context for the SSL session’s receive callback function. By default, wolfSSL sets the file descriptor passed to wolfSSL_set_fd() as the context when wolfSSL is using the system’s TCP library. If you’ve registered your own receive callback you may want to set a specific context for the session. For example, if you’re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers. ">wolfSSL_SetIOReadCtx</a> </dd>
<dd>
wolfSSL_SetIOSend </dd></dl>

</div>
</div>
<a id="a1103448119a1f924222980d9f12789ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1103448119a1f924222980d9f12789ad">&#9670;&nbsp;</a></span>wolfSSL_SetIO_NetX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wolfSSL_SetIO_NetX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NX_TCP_SOCKET *&#160;</td>
          <td class="paramname"><em>nxsocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>waitoption</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the nxSocket and nxWait members of the nxCtx struct within the <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a <a class="el" href="structWOLFSSL.html">WOLFSSL</a> structure, created using wolfSSL_new(). </td></tr>
    <tr><td class="paramname">nxSocket</td><td>a pointer to type NX_TCP_SOCKET that is set to the nxSocket member of the nxCTX structure. </td></tr>
    <tr><td class="paramname">waitOption</td><td>a ULONG type that is set to the nxWait member of the nxCtx structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = wolfSSL_new(ctx);</div><div class="line">NX_TCP_SOCKET* nxSocket;</div><div class="line">ULONG waitOption;</div><div class="line">…</div><div class="line"><span class="keywordflow">if</span>(ssl != NULL || nxSocket != NULL || waitOption &lt;= 0){ </div><div class="line"><a class="code" href="io_8h.html#a1103448119a1f924222980d9f12789ad">wolfSSL_SetIO_NetX</a>(ssl, nxSocket, waitOption);</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">    <span class="comment">// You need to pass in good parameters.</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>set_fd </dd>
<dd>
NetX_Send </dd>
<dd>
NetX_Receive </dd></dl>

</div>
</div>
<a id="a05215fdd13f28d0cce4e2e2020dd36a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05215fdd13f28d0cce4e2e2020dd36a3">&#9670;&nbsp;</a></span>wolfSSL_SetIOReadCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wolfSSL_SetIOReadCtx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers a context for the SSL session’s receive callback function. By default, <a class="el" href="namespacewolfSSL.html">wolfSSL</a> sets the file descriptor passed to wolfSSL_set_fd() as the context when <a class="el" href="namespacewolfSSL.html">wolfSSL</a> is using the system’s TCP library. If you’ve registered your own receive callback you may want to set a specific context for the session. For example, if you’re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with wolfSSL_new(). </td></tr>
    <tr><td class="paramname">rctx</td><td>pointer to the context to be registered with the SSL session’s (ssl) receive callback function.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sockfd;</div><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = 0;</div><div class="line">...</div><div class="line"><span class="comment">// Manually setting the socket fd as the receive CTX, for example</span></div><div class="line">wolfSSL_SetIOReadCtx(ssl, &amp;sockfd);</div><div class="line">...</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="io_8h.html#ae60b951edb103c2c16ec6ce19ba37ba8" title="This function registers a receive callback for wolfSSL to get input data. By default, wolfSSL uses EmbedReceive() as the callback which uses the system’s TCP recv() function. The user can register a function to get input from memory, some other network module, or from anywhere. Please see the EmbedReceive() function in src/io.c as a guide for how the function should work and for error codes. In particular, IO_ERR_WANT_READ should be returned for non blocking receive when no data is ready. ">wolfSSL_SetIORecv</a> </dd>
<dd>
wolfSSL_SetIOSend </dd>
<dd>
<a class="el" href="io_8h.html#a59cd261cda84bdb604d710744cc65d83" title="This function registers a context for the SSL session’s send callback function. By default...">wolfSSL_SetIOWriteCtx</a> </dd></dl>

</div>
</div>
<a id="a630457bd1121fc9b6aca55c0657b7f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630457bd1121fc9b6aca55c0657b7f55">&#9670;&nbsp;</a></span>wolfSSL_SetIOReadFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wolfSSL_SetIOReadFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the flags for the receive callback to use for the given SSL session. The receive callback could be either the default <a class="el" href="namespacewolfSSL.html">wolfSSL</a> EmbedReceive callback, or a custom callback specified by the user (see wolfSSL_SetIORecv). The default flag value is set internally by <a class="el" href="namespacewolfSSL.html">wolfSSL</a> to the value of 0. The default <a class="el" href="namespacewolfSSL.html">wolfSSL</a> receive callback uses the recv() function to receive data from the socket. From the recv() man page: “The flags argument to a recv() function is formed by or'ing one or more of the values: MSG_OOB process out-of-band data, MSG_PEEK peek at incoming message, MSG_WAITALL wait for full request or error. The MSG_OOB flag requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus this flag cannot be used with such protocols. The MSG_PEEK flag causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data. The MSG_WAITALL flag requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if a signal is caught, an error or disconnect occurs, or the next data to be received is of a different type than that returned.” </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with wolfSSL_new(). </td></tr>
    <tr><td class="paramname">flags</td><td>value of the I/O read flags for the specified SSL session (ssl).</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = 0;</div><div class="line">...</div><div class="line"><span class="comment">// Manually setting recv flags to 0</span></div><div class="line">wolfSSL_SetIOReadFlags(ssl, 0);</div><div class="line">...</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="io_8h.html#ae60b951edb103c2c16ec6ce19ba37ba8" title="This function registers a receive callback for wolfSSL to get input data. By default, wolfSSL uses EmbedReceive() as the callback which uses the system’s TCP recv() function. The user can register a function to get input from memory, some other network module, or from anywhere. Please see the EmbedReceive() function in src/io.c as a guide for how the function should work and for error codes. In particular, IO_ERR_WANT_READ should be returned for non blocking receive when no data is ready. ">wolfSSL_SetIORecv</a> </dd>
<dd>
wolfSSL_SetIOSend </dd>
<dd>
<a class="el" href="io_8h.html#a05215fdd13f28d0cce4e2e2020dd36a3" title="This function registers a context for the SSL session’s receive callback function. By default, wolfSSL sets the file descriptor passed to wolfSSL_set_fd() as the context when wolfSSL is using the system’s TCP library. If you’ve registered your own receive callback you may want to set a specific context for the session. For example, if you’re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers. ">wolfSSL_SetIOReadCtx</a> </dd></dl>

</div>
</div>
<a id="ae60b951edb103c2c16ec6ce19ba37ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60b951edb103c2c16ec6ce19ba37ba8">&#9670;&nbsp;</a></span>wolfSSL_SetIORecv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wolfSSL_SetIORecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackIORecv&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers a receive callback for <a class="el" href="namespacewolfSSL.html">wolfSSL</a> to get input data. By default, <a class="el" href="namespacewolfSSL.html">wolfSSL</a> uses <a class="el" href="io_8h.html#a02055ed06a40f0998c0981b348bed628" title="This function is the receive embedded callback. ">EmbedReceive()</a> as the callback which uses the system’s TCP recv() function. The user can register a function to get input from memory, some other network module, or from anywhere. Please see the <a class="el" href="io_8h.html#a02055ed06a40f0998c0981b348bed628" title="This function is the receive embedded callback. ">EmbedReceive()</a> function in src/io.c as a guide for how the function should work and for error codes. In particular, IO_ERR_WANT_READ should be returned for non blocking receive when no data is ready. </p>
<dl class="section return"><dt>Returns</dt><dd>none no Returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the SSL context, created with wolfSSL_CTX_new(). </td></tr>
    <tr><td class="paramname">callback</td><td>function to be registered as the receive callback for the <a class="el" href="namespacewolfSSL.html">wolfSSL</a> context, ctx. The signature of this function must follow that as shown above in the Synopsis section.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL__CTX.html">WOLFSSL_CTX</a>* ctx = 0;</div><div class="line"><span class="comment">// Receive callback prototype</span></div><div class="line"><span class="keywordtype">int</span> MyEmbedReceive(<a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl, <span class="keywordtype">char</span>* buf, <span class="keywordtype">int</span> sz, <span class="keywordtype">void</span>* ctx);</div><div class="line"><span class="comment">// Register the custom receive callback with wolfSSL</span></div><div class="line"><a class="code" href="io_8h.html#ae60b951edb103c2c16ec6ce19ba37ba8">wolfSSL_SetIORecv</a>(ctx, MyEmbedReceive);</div><div class="line"><span class="keywordtype">int</span> MyEmbedReceive(<a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl, <span class="keywordtype">char</span>* buf, <span class="keywordtype">int</span> sz, <span class="keywordtype">void</span>* ctx)                   </div><div class="line">{</div><div class="line"><span class="comment">// custom EmbedReceive function</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_SetIOSend </dd>
<dd>
<a class="el" href="io_8h.html#a05215fdd13f28d0cce4e2e2020dd36a3" title="This function registers a context for the SSL session’s receive callback function. By default, wolfSSL sets the file descriptor passed to wolfSSL_set_fd() as the context when wolfSSL is using the system’s TCP library. If you’ve registered your own receive callback you may want to set a specific context for the session. For example, if you’re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers. ">wolfSSL_SetIOReadCtx</a> </dd>
<dd>
<a class="el" href="io_8h.html#a59cd261cda84bdb604d710744cc65d83" title="This function registers a context for the SSL session’s send callback function. By default...">wolfSSL_SetIOWriteCtx</a> </dd></dl>

</div>
</div>
<a id="a59cd261cda84bdb604d710744cc65d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cd261cda84bdb604d710744cc65d83">&#9670;&nbsp;</a></span>wolfSSL_SetIOWriteCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wolfSSL_SetIOWriteCtx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers a context for the SSL session’s send callback function. By default, <a class="el" href="namespacewolfSSL.html">wolfSSL</a> sets the file descriptor passed to wolfSSL_set_fd() as the context when <a class="el" href="namespacewolfSSL.html">wolfSSL</a> is using the system’s TCP library. If you’ve registered your own send callback you may want to set a specific context for the session. For example, if you’re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with wolfSSL_new(). </td></tr>
    <tr><td class="paramname">wctx</td><td>pointer to the context to be registered with the SSL session’s (ssl) send callback function.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sockfd;</div><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = 0;</div><div class="line">...</div><div class="line"><span class="comment">// Manually setting the socket fd as the send CTX, for example</span></div><div class="line">wolfSSL_SetIOSendCtx(ssl, &amp;sockfd);</div><div class="line">...</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="io_8h.html#ae60b951edb103c2c16ec6ce19ba37ba8" title="This function registers a receive callback for wolfSSL to get input data. By default, wolfSSL uses EmbedReceive() as the callback which uses the system’s TCP recv() function. The user can register a function to get input from memory, some other network module, or from anywhere. Please see the EmbedReceive() function in src/io.c as a guide for how the function should work and for error codes. In particular, IO_ERR_WANT_READ should be returned for non blocking receive when no data is ready. ">wolfSSL_SetIORecv</a> </dd>
<dd>
wolfSSL_SetIOSend </dd>
<dd>
<a class="el" href="io_8h.html#a05215fdd13f28d0cce4e2e2020dd36a3" title="This function registers a context for the SSL session’s receive callback function. By default, wolfSSL sets the file descriptor passed to wolfSSL_set_fd() as the context when wolfSSL is using the system’s TCP library. If you’ve registered your own receive callback you may want to set a specific context for the session. For example, if you’re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers. ">wolfSSL_SetIOReadCtx</a> </dd></dl>

</div>
</div>
<a id="ab12cb9a1963b8dc9208ab1387bf67294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12cb9a1963b8dc9208ab1387bf67294">&#9670;&nbsp;</a></span>wolfSSL_SetIOWriteFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wolfSSL_SetIOWriteFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWOLFSSL.html">WOLFSSL</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the flags for the send callback to use for the given SSL session. The send callback could be either the default <a class="el" href="namespacewolfSSL.html">wolfSSL</a> EmbedSend callback, or a custom callback specified by the user (see wolfSSL_SetIOSend). The default flag value is set internally by <a class="el" href="namespacewolfSSL.html">wolfSSL</a> to the value of 0. The default <a class="el" href="namespacewolfSSL.html">wolfSSL</a> send callback uses the send() function to send data from the socket. From the send() man page: “The flags parameter may include one or more of the following: #define MSG_OOB 0x1 /* process out-of-band data, #define MSG_DONTROUTE 0x4 /* bypass routing, use direct interface. The flag MSG_OOB is used to send <code>out-of-band'' data on sockets that support this notion (e.g. SOCK_STREAM); the underlying protocol must also support</code>out-of-band'' data. MSG_DONTROUTE is usually used only by diagnostic or routing programs.” </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with wolfSSL_new(). </td></tr>
    <tr><td class="paramname">flags</td><td>value of the I/O send flags for the specified SSL session (ssl).</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structWOLFSSL.html">WOLFSSL</a>* ssl = 0;</div><div class="line">...</div><div class="line"><span class="comment">// Manually setting send flags to 0</span></div><div class="line">wolfSSL_SetIOSendFlags(ssl, 0);</div><div class="line">...</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="io_8h.html#ae60b951edb103c2c16ec6ce19ba37ba8" title="This function registers a receive callback for wolfSSL to get input data. By default, wolfSSL uses EmbedReceive() as the callback which uses the system’s TCP recv() function. The user can register a function to get input from memory, some other network module, or from anywhere. Please see the EmbedReceive() function in src/io.c as a guide for how the function should work and for error codes. In particular, IO_ERR_WANT_READ should be returned for non blocking receive when no data is ready. ">wolfSSL_SetIORecv</a> </dd>
<dd>
wolfSSL_SetIOSend </dd>
<dd>
<a class="el" href="io_8h.html#a05215fdd13f28d0cce4e2e2020dd36a3" title="This function registers a context for the SSL session’s receive callback function. By default, wolfSSL sets the file descriptor passed to wolfSSL_set_fd() as the context when wolfSSL is using the system’s TCP library. If you’ve registered your own receive callback you may want to set a specific context for the session. For example, if you’re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers. ">wolfSSL_SetIOReadCtx</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
