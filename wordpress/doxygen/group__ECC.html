<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithms - ECC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms - ECC</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad510edd30f492a95fe70b3f8588362e8"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gad510edd30f492a95fe70b3f8588362e8">wc_ecc_make_key</a> (<a class="el" href="structWC__RNG.html">WC_RNG</a> *rng, int keysize, <a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:gad510edd30f492a95fe70b3f8588362e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a new <a class="el" href="structecc__key.html">ecc_key</a> and stores it in key.  <a href="#gad510edd30f492a95fe70b3f8588362e8">More...</a><br /></td></tr>
<tr class="separator:gad510edd30f492a95fe70b3f8588362e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b72d7ccb8a8d173b453734bacd9c128"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga8b72d7ccb8a8d173b453734bacd9c128">wc_ecc_check_key</a> (<a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:ga8b72d7ccb8a8d173b453734bacd9c128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sanity checks on ecc key validity.  <a href="#ga8b72d7ccb8a8d173b453734bacd9c128">More...</a><br /></td></tr>
<tr class="separator:ga8b72d7ccb8a8d173b453734bacd9c128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab92c015b38d6f61f339e7412500dcf83"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gab92c015b38d6f61f339e7412500dcf83">wc_ecc_shared_secret</a> (<a class="el" href="structecc__key.html">ecc_key</a> *private_key, <a class="el" href="structecc__key.html">ecc_key</a> *public_key, byte *out, word32 *outlen)</td></tr>
<tr class="memdesc:gab92c015b38d6f61f339e7412500dcf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a new secret key using a local private key and a received public key. It stores this shared secret key in the buffer out and updates outlen to hold the number of bytes written to the output buffer.  <a href="#gab92c015b38d6f61f339e7412500dcf83">More...</a><br /></td></tr>
<tr class="separator:gab92c015b38d6f61f339e7412500dcf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5218fab8c7043ed4d64dc34e8d2bd9d5"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga5218fab8c7043ed4d64dc34e8d2bd9d5">wc_ecc_shared_secret_ex</a> (<a class="el" href="structecc__key.html">ecc_key</a> *private_key, <a class="el" href="structecc__point.html">ecc_point</a> *point, byte *out, word32 *outlen)</td></tr>
<tr class="memdesc:ga5218fab8c7043ed4d64dc34e8d2bd9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ECC shared secret between private key and public point.  <a href="#ga5218fab8c7043ed4d64dc34e8d2bd9d5">More...</a><br /></td></tr>
<tr class="separator:ga5218fab8c7043ed4d64dc34e8d2bd9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0de1f56d50dcd1eb684a0e2a45eebf27"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga0de1f56d50dcd1eb684a0e2a45eebf27">wc_ecc_sign_hash</a> (const byte *in, word32 inlen, byte *out, word32 *outlen, <a class="el" href="structWC__RNG.html">WC_RNG</a> *rng, <a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:ga0de1f56d50dcd1eb684a0e2a45eebf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function signs a message digest using an <a class="el" href="structecc__key.html">ecc_key</a> object to guarantee authenticity.  <a href="#ga0de1f56d50dcd1eb684a0e2a45eebf27">More...</a><br /></td></tr>
<tr class="separator:ga0de1f56d50dcd1eb684a0e2a45eebf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a2f2f85cf87e05dcc6077ea26c7f25"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga10a2f2f85cf87e05dcc6077ea26c7f25">wc_ecc_sign_hash_ex</a> (const byte *in, word32 inlen, <a class="el" href="structWC__RNG.html">WC_RNG</a> *rng, <a class="el" href="structecc__key.html">ecc_key</a> *key, <a class="el" href="structmp__int.html">mp_int</a> *r, <a class="el" href="structmp__int.html">mp_int</a> *s)</td></tr>
<tr class="memdesc:ga10a2f2f85cf87e05dcc6077ea26c7f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a message digest.  <a href="#ga10a2f2f85cf87e05dcc6077ea26c7f25">More...</a><br /></td></tr>
<tr class="separator:ga10a2f2f85cf87e05dcc6077ea26c7f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c60fc76d5566f23f73f43d31f29fe0"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga89c60fc76d5566f23f73f43d31f29fe0">wc_ecc_verify_hash</a> (const byte *sig, word32 siglen, const byte *hash, word32 hashlen, int *stat, <a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:ga89c60fc76d5566f23f73f43d31f29fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function verifies the ECC signature of a hash to ensure authenticity. It returns the answer through stat, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature.  <a href="#ga89c60fc76d5566f23f73f43d31f29fe0">More...</a><br /></td></tr>
<tr class="separator:ga89c60fc76d5566f23f73f43d31f29fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24071ff7fd61458687dfd13f5129fdaa"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga24071ff7fd61458687dfd13f5129fdaa">wc_ecc_verify_hash_ex</a> (<a class="el" href="structmp__int.html">mp_int</a> *r, <a class="el" href="structmp__int.html">mp_int</a> *s, const byte *hash, word32 hashlen, int *stat, <a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:ga24071ff7fd61458687dfd13f5129fdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the return value to test for valid. Only use stat.  <a href="#ga24071ff7fd61458687dfd13f5129fdaa">More...</a><br /></td></tr>
<tr class="separator:ga24071ff7fd61458687dfd13f5129fdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32dc4d612f1b9385d9276a2370d6d94"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94">wc_ecc_init</a> (<a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:gaa32dc4d612f1b9385d9276a2370d6d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an <a class="el" href="structecc__key.html">ecc_key</a> object for future use with message verification or key negotiation.  <a href="#gaa32dc4d612f1b9385d9276a2370d6d94">More...</a><br /></td></tr>
<tr class="separator:gaa32dc4d612f1b9385d9276a2370d6d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8bd7d0557a101d940b70f144f9d7a97"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gae8bd7d0557a101d940b70f144f9d7a97">wc_ecc_free</a> (<a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:gae8bd7d0557a101d940b70f144f9d7a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees an <a class="el" href="structecc__key.html">ecc_key</a> object after it has been used.  <a href="#gae8bd7d0557a101d940b70f144f9d7a97">More...</a><br /></td></tr>
<tr class="separator:gae8bd7d0557a101d940b70f144f9d7a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f69ab2fd9b5c89ba1ec7f65f5bccb0"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gae4f69ab2fd9b5c89ba1ec7f65f5bccb0">wc_ecc_fp_free</a> (void)</td></tr>
<tr class="memdesc:gae4f69ab2fd9b5c89ba1ec7f65f5bccb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees the fixed-point cache, which can be used with ecc to speed up computation times. To use this functionality, FP_ECC (fixed-point ecc), should be defined.  <a href="#gae4f69ab2fd9b5c89ba1ec7f65f5bccb0">More...</a><br /></td></tr>
<tr class="separator:gae4f69ab2fd9b5c89ba1ec7f65f5bccb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ca84e578ae39aca382a05b8aabf8877"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga3ca84e578ae39aca382a05b8aabf8877">wc_ecc_is_valid_idx</a> (int n)</td></tr>
<tr class="memdesc:ga3ca84e578ae39aca382a05b8aabf8877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an ECC idx is valid.  <a href="#ga3ca84e578ae39aca382a05b8aabf8877">More...</a><br /></td></tr>
<tr class="separator:ga3ca84e578ae39aca382a05b8aabf8877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga875fb9dc7833d12d5f2661a8ba1880a4"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API <a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4">wc_ecc_new_point</a> (void)</td></tr>
<tr class="memdesc:ga875fb9dc7833d12d5f2661a8ba1880a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new ECC point.  <a href="#ga875fb9dc7833d12d5f2661a8ba1880a4">More...</a><br /></td></tr>
<tr class="separator:ga875fb9dc7833d12d5f2661a8ba1880a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3992a20c8d2567a89e17bde7bc09ed09"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga3992a20c8d2567a89e17bde7bc09ed09">wc_ecc_del_point</a> (<a class="el" href="structecc__point.html">ecc_point</a> *p)</td></tr>
<tr class="memdesc:ga3992a20c8d2567a89e17bde7bc09ed09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an ECC point from memory.  <a href="#ga3992a20c8d2567a89e17bde7bc09ed09">More...</a><br /></td></tr>
<tr class="separator:ga3992a20c8d2567a89e17bde7bc09ed09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ed1510ea50301ea021e820082eb7ba"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga17ed1510ea50301ea021e820082eb7ba">wc_ecc_copy_point</a> (<a class="el" href="structecc__point.html">ecc_point</a> *p, <a class="el" href="structecc__point.html">ecc_point</a> *r)</td></tr>
<tr class="memdesc:ga17ed1510ea50301ea021e820082eb7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the value of one point to another one.  <a href="#ga17ed1510ea50301ea021e820082eb7ba">More...</a><br /></td></tr>
<tr class="separator:ga17ed1510ea50301ea021e820082eb7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12592d79567f39f662708e71da8cb53e"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga12592d79567f39f662708e71da8cb53e">wc_ecc_cmp_point</a> (<a class="el" href="structecc__point.html">ecc_point</a> *a, <a class="el" href="structecc__point.html">ecc_point</a> *b)</td></tr>
<tr class="memdesc:ga12592d79567f39f662708e71da8cb53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the value of a point with another one.  <a href="#ga12592d79567f39f662708e71da8cb53e">More...</a><br /></td></tr>
<tr class="separator:ga12592d79567f39f662708e71da8cb53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2753e5e519730482314f381ebcf7a6c2"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga2753e5e519730482314f381ebcf7a6c2">wc_ecc_point_is_at_infinity</a> (<a class="el" href="structecc__point.html">ecc_point</a> *p)</td></tr>
<tr class="memdesc:ga2753e5e519730482314f381ebcf7a6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a point is at infinity. Returns 1 if point is at infinity, 0 if not, &lt; 0 on error.  <a href="#ga2753e5e519730482314f381ebcf7a6c2">More...</a><br /></td></tr>
<tr class="separator:ga2753e5e519730482314f381ebcf7a6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd60b6f104018b22af7a7700a676e057"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gacd60b6f104018b22af7a7700a676e057">wc_ecc_mulmod</a> (<a class="el" href="structmp__int.html">mp_int</a> *k, <a class="el" href="structecc__point.html">ecc_point</a> *G, <a class="el" href="structecc__point.html">ecc_point</a> *R, <a class="el" href="structmp__int.html">mp_int</a> *a, <a class="el" href="structmp__int.html">mp_int</a> *modulus, int map)</td></tr>
<tr class="memdesc:gacd60b6f104018b22af7a7700a676e057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ECC Fixed Point multiplication.  <a href="#gacd60b6f104018b22af7a7700a676e057">More...</a><br /></td></tr>
<tr class="separator:gacd60b6f104018b22af7a7700a676e057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebea0f5ac7cf38c4bf3d995b7047fa22"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaebea0f5ac7cf38c4bf3d995b7047fa22">wc_ecc_export_x963</a> (<a class="el" href="structecc__key.html">ecc_key</a> *, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:gaebea0f5ac7cf38c4bf3d995b7047fa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports the ECC key from the <a class="el" href="structecc__key.html">ecc_key</a> structure, storing the result in out. The key will be stored in ANSI X9.63 format. It stores the bytes written to the output buffer in outLen.  <a href="#gaebea0f5ac7cf38c4bf3d995b7047fa22">More...</a><br /></td></tr>
<tr class="separator:gaebea0f5ac7cf38c4bf3d995b7047fa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9bde81714fc7a024674171dd857e1b9"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gae9bde81714fc7a024674171dd857e1b9">wc_ecc_export_x963_ex</a> (<a class="el" href="structecc__key.html">ecc_key</a> *, byte *out, word32 *outLen, int compressed)</td></tr>
<tr class="memdesc:gae9bde81714fc7a024674171dd857e1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports the ECC key from the <a class="el" href="structecc__key.html">ecc_key</a> structure, storing the result in out. The key will be stored in ANSI X9.63 format. It stores the bytes written to the output buffer in outLen. This function allows the additional option of compressing the certificate through the compressed parameter. When this parameter is true, the key will be stored in ANSI X9.63 compressed format.  <a href="#gae9bde81714fc7a024674171dd857e1b9">More...</a><br /></td></tr>
<tr class="separator:gae9bde81714fc7a024674171dd857e1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8121a4cfcd09c26eb12401ca82b4a56d"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga8121a4cfcd09c26eb12401ca82b4a56d">wc_ecc_import_x963</a> (const byte *in, word32 inLen, <a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:ga8121a4cfcd09c26eb12401ca82b4a56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports a public ECC key from a buffer containing the key stored in ANSI X9.63 format. This function will handle both compressed and uncompressed keys, as long as compressed keys are enabled at compile time through the HAVE_COMP_KEY option.  <a href="#ga8121a4cfcd09c26eb12401ca82b4a56d">More...</a><br /></td></tr>
<tr class="separator:ga8121a4cfcd09c26eb12401ca82b4a56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf692ee35f6f8d9da48fe0fd9eacf9d"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga5cf692ee35f6f8d9da48fe0fd9eacf9d">wc_ecc_import_private_key</a> (const byte *priv, word32 privSz, const byte *pub, word32 pubSz, <a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:ga5cf692ee35f6f8d9da48fe0fd9eacf9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports a public/private ECC key pair from a buffer containing the raw private key, and a second buffer containing the ANSI X9.63 formatted public key. This function will handle both compressed and uncompressed keys, as long as compressed keys are enabled at compile time through the HAVE_COMP_KEY option.  <a href="#ga5cf692ee35f6f8d9da48fe0fd9eacf9d">More...</a><br /></td></tr>
<tr class="separator:ga5cf692ee35f6f8d9da48fe0fd9eacf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8670c34f6078bad922140c8b933969d0"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga8670c34f6078bad922140c8b933969d0">wc_ecc_rs_to_sig</a> (const char *r, const char *s, byte *out, word32 *outlen)</td></tr>
<tr class="memdesc:ga8670c34f6078bad922140c8b933969d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the R and S portions of an ECC signature into a DER-encoded ECDSA signature. This function also stores the length written to the output buffer, out, in outlen.  <a href="#ga8670c34f6078bad922140c8b933969d0">More...</a><br /></td></tr>
<tr class="separator:ga8670c34f6078bad922140c8b933969d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3527442083c437ed706308c8be95b59"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gab3527442083c437ed706308c8be95b59">wc_ecc_import_raw</a> (<a class="el" href="structecc__key.html">ecc_key</a> *key, const char *qx, const char *qy, const char *d, const char *curveName)</td></tr>
<tr class="memdesc:gab3527442083c437ed706308c8be95b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills an <a class="el" href="structecc__key.html">ecc_key</a> structure with the raw components of an ECC signature.  <a href="#gab3527442083c437ed706308c8be95b59">More...</a><br /></td></tr>
<tr class="separator:gab3527442083c437ed706308c8be95b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a68cd1f5b6fc061d4c9f203446a56b"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gac2a68cd1f5b6fc061d4c9f203446a56b">wc_ecc_export_private_only</a> (<a class="el" href="structecc__key.html">ecc_key</a> *key, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:gac2a68cd1f5b6fc061d4c9f203446a56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports only the private key from an <a class="el" href="structecc__key.html">ecc_key</a> structure. It stores the private key in the buffer out, and sets the bytes written to this buffer in outLen.  <a href="#gac2a68cd1f5b6fc061d4c9f203446a56b">More...</a><br /></td></tr>
<tr class="separator:gac2a68cd1f5b6fc061d4c9f203446a56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e4777dc90bb61b29dbdd8f9ef51b16"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga45e4777dc90bb61b29dbdd8f9ef51b16">wc_ecc_export_point_der</a> (const int curve_idx, <a class="el" href="structecc__point.html">ecc_point</a> *point, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:ga45e4777dc90bb61b29dbdd8f9ef51b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export point to der.  <a href="#ga45e4777dc90bb61b29dbdd8f9ef51b16">More...</a><br /></td></tr>
<tr class="separator:ga45e4777dc90bb61b29dbdd8f9ef51b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae5216e693d446086fa1de57eef4d4a4"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaae5216e693d446086fa1de57eef4d4a4">wc_ecc_import_point_der</a> (byte *in, word32 inLen, const int curve_idx, <a class="el" href="structecc__point.html">ecc_point</a> *point)</td></tr>
<tr class="memdesc:gaae5216e693d446086fa1de57eef4d4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import point from der format.  <a href="#gaae5216e693d446086fa1de57eef4d4a4">More...</a><br /></td></tr>
<tr class="separator:gaae5216e693d446086fa1de57eef4d4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98fe576e4be2e211ae687520bbf54cd8"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga98fe576e4be2e211ae687520bbf54cd8">wc_ecc_size</a> (<a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:ga98fe576e4be2e211ae687520bbf54cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the key size of an <a class="el" href="structecc__key.html">ecc_key</a> structure in octets.  <a href="#ga98fe576e4be2e211ae687520bbf54cd8">More...</a><br /></td></tr>
<tr class="separator:ga98fe576e4be2e211ae687520bbf54cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf181e4ceefcf3e5ad05d16aeeaa6dc6c"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaf181e4ceefcf3e5ad05d16aeeaa6dc6c">wc_ecc_sig_size</a> (<a class="el" href="structecc__key.html">ecc_key</a> *key)</td></tr>
<tr class="memdesc:gaf181e4ceefcf3e5ad05d16aeeaa6dc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the worst case size for an ECC signature, given by: keySz * 2 + SIG_HEADER_SZ + 4 The actual signature size can be computed with wc_ecc_sign_hash.  <a href="#gaf181e4ceefcf3e5ad05d16aeeaa6dc6c">More...</a><br /></td></tr>
<tr class="separator:gaf181e4ceefcf3e5ad05d16aeeaa6dc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc55ff3a455341d143786e8a27c8bbbe"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API <a class="el" href="structecEncCtx.html">ecEncCtx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe">wc_ecc_ctx_new</a> (int flags, <a class="el" href="structWC__RNG.html">WC_RNG</a> *rng)</td></tr>
<tr class="memdesc:gafc55ff3a455341d143786e8a27c8bbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates and initializes space for a new ECC context object to allow secure message exchange with ECC.  <a href="#gafc55ff3a455341d143786e8a27c8bbbe">More...</a><br /></td></tr>
<tr class="separator:gafc55ff3a455341d143786e8a27c8bbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a1d8f2f377a3aa2d8ce764f5c009b7"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gac5a1d8f2f377a3aa2d8ce764f5c009b7">wc_ecc_ctx_free</a> (<a class="el" href="structecEncCtx.html">ecEncCtx</a> *)</td></tr>
<tr class="memdesc:gac5a1d8f2f377a3aa2d8ce764f5c009b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees the <a class="el" href="structecEncCtx.html">ecEncCtx</a> object used for encrypting and decrypting messages.  <a href="#gac5a1d8f2f377a3aa2d8ce764f5c009b7">More...</a><br /></td></tr>
<tr class="separator:gac5a1d8f2f377a3aa2d8ce764f5c009b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a31646e5168787ccb2a25781f45db68"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga8a31646e5168787ccb2a25781f45db68">wc_ecc_ctx_reset</a> (<a class="el" href="structecEncCtx.html">ecEncCtx</a> *, <a class="el" href="structWC__RNG.html">WC_RNG</a> *)</td></tr>
<tr class="memdesc:ga8a31646e5168787ccb2a25781f45db68"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets an <a class="el" href="structecEncCtx.html">ecEncCtx</a> structure to avoid having to free and allocate a new context object.  <a href="#ga8a31646e5168787ccb2a25781f45db68">More...</a><br /></td></tr>
<tr class="separator:ga8a31646e5168787ccb2a25781f45db68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fed993abfc221d34fafa5c7cab9f27e"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API const byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga9fed993abfc221d34fafa5c7cab9f27e">wc_ecc_ctx_get_own_salt</a> (<a class="el" href="structecEncCtx.html">ecEncCtx</a> *)</td></tr>
<tr class="memdesc:ga9fed993abfc221d34fafa5c7cab9f27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the salt of an <a class="el" href="structecEncCtx.html">ecEncCtx</a> object. This function should only be called when the <a class="el" href="structecEncCtx.html">ecEncCtx</a>'s state is ecSRV_INIT or ecCLI_INIT.  <a href="#ga9fed993abfc221d34fafa5c7cab9f27e">More...</a><br /></td></tr>
<tr class="separator:ga9fed993abfc221d34fafa5c7cab9f27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c20bea691ecc33b2e00f1ac5bf8ddeb"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga6c20bea691ecc33b2e00f1ac5bf8ddeb">wc_ecc_ctx_set_peer_salt</a> (<a class="el" href="structecEncCtx.html">ecEncCtx</a> *, const byte *salt)</td></tr>
<tr class="memdesc:ga6c20bea691ecc33b2e00f1ac5bf8ddeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the peer salt of an <a class="el" href="structecEncCtx.html">ecEncCtx</a> object.  <a href="#ga6c20bea691ecc33b2e00f1ac5bf8ddeb">More...</a><br /></td></tr>
<tr class="separator:ga6c20bea691ecc33b2e00f1ac5bf8ddeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12da6900fb0c19396e838b63aea78e23"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga12da6900fb0c19396e838b63aea78e23">wc_ecc_ctx_set_info</a> (<a class="el" href="structecEncCtx.html">ecEncCtx</a> *, const byte *info, int sz)</td></tr>
<tr class="memdesc:ga12da6900fb0c19396e838b63aea78e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can optionally be called before or after wc_ecc_ctx_set_peer_salt. It sets optional information for an <a class="el" href="structecEncCtx.html">ecEncCtx</a> object.  <a href="#ga12da6900fb0c19396e838b63aea78e23">More...</a><br /></td></tr>
<tr class="separator:ga12da6900fb0c19396e838b63aea78e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c0c73b9dd43f4101afdca32b9795b2"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaf5c0c73b9dd43f4101afdca32b9795b2">wc_ecc_encrypt</a> (<a class="el" href="structecc__key.html">ecc_key</a> *privKey, <a class="el" href="structecc__key.html">ecc_key</a> *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, <a class="el" href="structecEncCtx.html">ecEncCtx</a> *ctx)</td></tr>
<tr class="memdesc:gaf5c0c73b9dd43f4101afdca32b9795b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts the given input message from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the <a class="el" href="structecEncCtx.html">ecEncCtx</a>'s encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx.  <a href="#gaf5c0c73b9dd43f4101afdca32b9795b2">More...</a><br /></td></tr>
<tr class="separator:gaf5c0c73b9dd43f4101afdca32b9795b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d79bc0005249de9da2ad9804aca27e6"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga1d79bc0005249de9da2ad9804aca27e6">wc_ecc_decrypt</a> (<a class="el" href="structecc__key.html">ecc_key</a> *privKey, <a class="el" href="structecc__key.html">ecc_key</a> *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, <a class="el" href="structecEncCtx.html">ecEncCtx</a> *ctx)</td></tr>
<tr class="memdesc:ga1d79bc0005249de9da2ad9804aca27e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the <a class="el" href="structecEncCtx.html">ecEncCtx</a>'s encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx.  <a href="#ga1d79bc0005249de9da2ad9804aca27e6">More...</a><br /></td></tr>
<tr class="separator:ga1d79bc0005249de9da2ad9804aca27e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8b72d7ccb8a8d173b453734bacd9c128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b72d7ccb8a8d173b453734bacd9c128">&#9670;&nbsp;</a></span>wc_ecc_check_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_check_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sanity checks on ecc key validity. </p>
<dl class="section return"><dt>Returns</dt><dd>MP_OKAY Success, key is OK. </dd>
<dd>
BAD_FUNC_ARG Returns if key is NULL. </dd>
<dd>
ECC_INF_E Returns if wc_ecc_point_is_at_infinity returns 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to key to check.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line">RNG rng;</div><div class="line"><span class="keywordtype">int</span> check_result;</div><div class="line"><a class="code" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94">wc_ecc_init</a>(&amp;key);</div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line"><a class="code" href="group__ECC.html#gad510edd30f492a95fe70b3f8588362e8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key);</div><div class="line">check_result = <a class="code" href="group__ECC.html#ga8b72d7ccb8a8d173b453734bacd9c128">wc_ecc_check_key</a>(&amp;key);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (check_result == MP_OKAY)</div><div class="line">{</div><div class="line">    <span class="comment">// key check succeeded</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="comment">// key check failed</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga2753e5e519730482314f381ebcf7a6c2" title="Checks if a point is at infinity. Returns 1 if point is at infinity, 0 if not, &lt; 0 on error...">wc_ecc_point_is_at_infinity</a> </dd></dl>

</div>
</div>
<a id="ga12592d79567f39f662708e71da8cb53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12592d79567f39f662708e71da8cb53e">&#9670;&nbsp;</a></span>wc_ecc_cmp_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_cmp_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the value of a point with another one. </p>
<dl class="section return"><dt>Returns</dt><dd>BAD_FUNC_ARG One or both arguments are NULL. </dd>
<dd>
MP_EQ The points are equal. </dd>
<dd>
ret Either MP_LT or MP_GT and signifies that the points are not equal.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First point to compare. </td></tr>
    <tr><td class="paramname">b</td><td>Second point to compare.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* point;</div><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* point_to_compare;</div><div class="line"><span class="keywordtype">int</span> cmp_result;</div><div class="line"></div><div class="line">point = <a class="code" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4">wc_ecc_new_point</a>();</div><div class="line">point_to_compare = <a class="code" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4">wc_ecc_new_point</a>();</div><div class="line">cmp_result = <a class="code" href="group__ECC.html#ga12592d79567f39f662708e71da8cb53e">wc_ecc_cmp_point</a>(point, point_to_compare);</div><div class="line"><span class="keywordflow">if</span> (cmp_result == BAD_FUNC_ARG)</div><div class="line">{</div><div class="line">    <span class="comment">// arguments are invalid</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmp_result == MP_EQ)</div><div class="line">{</div><div class="line">    <span class="comment">// Points are equal</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="comment">// Points are not equal</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4" title="Allocate a new ECC point. ">wc_ecc_new_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga3992a20c8d2567a89e17bde7bc09ed09" title="Free an ECC point from memory. ">wc_ecc_del_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga17ed1510ea50301ea021e820082eb7ba" title="Copy the value of one point to another one. ">wc_ecc_copy_point</a></dd></dl>
<p>Compare the value of a point with an other one a The point to compare b The other point to compare</p>
<p>return MP_EQ if equal, MP_LT/MP_GT if not, &lt; 0 in case of error </p>

</div>
</div>
<a id="ga17ed1510ea50301ea021e820082eb7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17ed1510ea50301ea021e820082eb7ba">&#9670;&nbsp;</a></span>wc_ecc_copy_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_copy_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the value of one point to another one. </p>
<dl class="section return"><dt>Returns</dt><dd>ECC_BAD_ARG_E Error thrown when p or r is null. </dd>
<dd>
MP_OKAY Point copied successfully </dd>
<dd>
ret Error from internal functions. Can be...</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to copy. </td></tr>
    <tr><td class="paramname">r</td><td>The created point.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* point;</div><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* copied_point;</div><div class="line"><span class="keywordtype">int</span> copy_return;</div><div class="line"></div><div class="line">point = <a class="code" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4">wc_ecc_new_point</a>();</div><div class="line">copy_return = <a class="code" href="group__ECC.html#ga17ed1510ea50301ea021e820082eb7ba">wc_ecc_copy_point</a>(point, copied_point);</div><div class="line"><span class="keywordflow">if</span> (copy_return != MP_OKAY)</div><div class="line">{</div><div class="line">    <span class="comment">// Handle error</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4" title="Allocate a new ECC point. ">wc_ecc_new_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga12592d79567f39f662708e71da8cb53e" title="Compare the value of a point with another one. ">wc_ecc_cmp_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga3992a20c8d2567a89e17bde7bc09ed09" title="Free an ECC point from memory. ">wc_ecc_del_point</a></dd></dl>
<p>Copy the value of a point to an other one p The point to copy r The created point </p>

</div>
</div>
<a id="gac5a1d8f2f377a3aa2d8ce764f5c009b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5a1d8f2f377a3aa2d8ce764f5c009b7">&#9670;&nbsp;</a></span>wc_ecc_ctx_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wc_ecc_ctx_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecEncCtx.html">ecEncCtx</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees the <a class="el" href="structecEncCtx.html">ecEncCtx</a> object used for encrypting and decrypting messages. </p>
<dl class="section return"><dt>Returns</dt><dd>none Returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the <a class="el" href="structecEncCtx.html">ecEncCtx</a> object to free</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecEncCtx.html">ecEncCtx</a>* ctx;</div><div class="line">RNG rng;</div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line">ctx = <a class="code" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe">wc_ecc_ctx_new</a>(REQ_RESP_CLIENT, &amp;rng);</div><div class="line"><span class="comment">// do secure communication</span></div><div class="line">...</div><div class="line">wc_ecc_ctx_free(&amp;ctx);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe" title="This function allocates and initializes space for a new ECC context object to allow secure message ex...">wc_ecc_ctx_new</a> </dd></dl>

</div>
</div>
<a id="ga9fed993abfc221d34fafa5c7cab9f27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fed993abfc221d34fafa5c7cab9f27e">&#9670;&nbsp;</a></span>wc_ecc_ctx_get_own_salt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API const byte* wc_ecc_ctx_get_own_salt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecEncCtx.html">ecEncCtx</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the salt of an <a class="el" href="structecEncCtx.html">ecEncCtx</a> object. This function should only be called when the <a class="el" href="structecEncCtx.html">ecEncCtx</a>'s state is ecSRV_INIT or ecCLI_INIT. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On success, returns the <a class="el" href="structecEncCtx.html">ecEncCtx</a> salt </dd>
<dd>
NULL Returned if the <a class="el" href="structecEncCtx.html">ecEncCtx</a> object is NULL, or the <a class="el" href="structecEncCtx.html">ecEncCtx</a>'s state is not ecSRV_INIT or ecCLI_INIT. In the latter two cases, this function also sets the <a class="el" href="structecEncCtx.html">ecEncCtx</a>'s state to ecSRV_BAD_STATE or ecCLI_BAD_STATE, respectively</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the <a class="el" href="structecEncCtx.html">ecEncCtx</a> object from which to get the salt</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecEncCtx.html">ecEncCtx</a>* ctx;</div><div class="line">RNG rng;</div><div class="line"><span class="keyword">const</span> byte* salt;</div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line">ctx = <a class="code" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe">wc_ecc_ctx_new</a>(REQ_RESP_CLIENT, &amp;rng);</div><div class="line">salt = <a class="code" href="group__ECC.html#ga9fed993abfc221d34fafa5c7cab9f27e">wc_ecc_ctx_get_own_salt</a>(&amp;ctx);</div><div class="line"><span class="keywordflow">if</span>(salt == NULL) {</div><div class="line">    <span class="comment">// error getting salt</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe" title="This function allocates and initializes space for a new ECC context object to allow secure message ex...">wc_ecc_ctx_new</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga6c20bea691ecc33b2e00f1ac5bf8ddeb" title="This function sets the peer salt of an ecEncCtx object. ">wc_ecc_ctx_set_peer_salt</a> </dd></dl>

</div>
</div>
<a id="gafc55ff3a455341d143786e8a27c8bbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc55ff3a455341d143786e8a27c8bbbe">&#9670;&nbsp;</a></span>wc_ecc_ctx_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API <a class="el" href="structecEncCtx.html">ecEncCtx</a>* wc_ecc_ctx_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWC__RNG.html">WC_RNG</a> *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates and initializes space for a new ECC context object to allow secure message exchange with ECC. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On successfully generating a new <a class="el" href="structecEncCtx.html">ecEncCtx</a> object, returns a pointer to that object </dd>
<dd>
NULL Returned if the function fails to generate a new <a class="el" href="structecEncCtx.html">ecEncCtx</a> object</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>indicate whether this is a server or client context <a class="el" href="structOptions.html">Options</a> are: REQ_RESP_CLIENT, and REQ_RESP_SERVER </td></tr>
    <tr><td class="paramname">rng</td><td>pointer to a RNG object with which to generate a salt</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecEncCtx.html">ecEncCtx</a>* ctx;</div><div class="line">RNG rng;</div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line">ctx = <a class="code" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe">wc_ecc_ctx_new</a>(REQ_RESP_CLIENT, &amp;rng);</div><div class="line"><span class="keywordflow">if</span>(ctx == NULL) {</div><div class="line">    <span class="comment">// error generating new ecEncCtx object</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gaf5c0c73b9dd43f4101afdca32b9795b2" title="This function encrypts the given input message from msg to out. This function takes an optional ctx o...">wc_ecc_encrypt</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga1d79bc0005249de9da2ad9804aca27e6" title="This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as ...">wc_ecc_decrypt</a> </dd></dl>

</div>
</div>
<a id="ga8a31646e5168787ccb2a25781f45db68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a31646e5168787ccb2a25781f45db68">&#9670;&nbsp;</a></span>wc_ecc_ctx_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_ctx_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecEncCtx.html">ecEncCtx</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWC__RNG.html">WC_RNG</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets an <a class="el" href="structecEncCtx.html">ecEncCtx</a> structure to avoid having to free and allocate a new context object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned if the <a class="el" href="structecEncCtx.html">ecEncCtx</a> structure is successfully reset </dd>
<dd>
BAD_FUNC_ARG Returned if either rng or ctx is NULL </dd>
<dd>
RNG_FAILURE_E Returned if there is an error generating a new salt for the ECC object</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the <a class="el" href="structecEncCtx.html">ecEncCtx</a> object to reset </td></tr>
    <tr><td class="paramname">rng</td><td>pointer to an RNG object with which to generate a new salt</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecEncCtx.html">ecEncCtx</a>* ctx;</div><div class="line">RNG rng;</div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line">ctx = <a class="code" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe">wc_ecc_ctx_new</a>(REQ_RESP_CLIENT, &amp;rng);</div><div class="line"><span class="comment">// do secure communication</span></div><div class="line">...</div><div class="line">wc_ecc_ctx_reset(&amp;ctx, &amp;rng);</div><div class="line"><span class="comment">// do more secure communication</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe" title="This function allocates and initializes space for a new ECC context object to allow secure message ex...">wc_ecc_ctx_new</a> </dd></dl>

</div>
</div>
<a id="ga12da6900fb0c19396e838b63aea78e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12da6900fb0c19396e838b63aea78e23">&#9670;&nbsp;</a></span>wc_ecc_ctx_set_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_ctx_set_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecEncCtx.html">ecEncCtx</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can optionally be called before or after wc_ecc_ctx_set_peer_salt. It sets optional information for an <a class="el" href="structecEncCtx.html">ecEncCtx</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully setting the information for the <a class="el" href="structecEncCtx.html">ecEncCtx</a> object. </dd>
<dd>
BAD_FUNC_ARG Returned if the given <a class="el" href="structecEncCtx.html">ecEncCtx</a> object is NULL, the input info is NULL or it's size is invalid</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the <a class="el" href="structecEncCtx.html">ecEncCtx</a> for which to set the info </td></tr>
    <tr><td class="paramname">info</td><td>pointer to a buffer containing the info to set </td></tr>
    <tr><td class="paramname">sz</td><td>size of the info buffer</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecEncCtx.html">ecEncCtx</a>* ctx;</div><div class="line">byte info[] = { <span class="comment">// initialize with information };</span></div><div class="line"><span class="comment">// initialize ctx, get salt,</span></div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__ECC.html#ga12da6900fb0c19396e838b63aea78e23">wc_ecc_ctx_set_info</a>(&amp;ctx, info, <span class="keyword">sizeof</span>(info))) {</div><div class="line">    <span class="comment">// error setting info</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe" title="This function allocates and initializes space for a new ECC context object to allow secure message ex...">wc_ecc_ctx_new</a> </dd></dl>

</div>
</div>
<a id="ga6c20bea691ecc33b2e00f1ac5bf8ddeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c20bea691ecc33b2e00f1ac5bf8ddeb">&#9670;&nbsp;</a></span>wc_ecc_ctx_set_peer_salt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_ctx_set_peer_salt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecEncCtx.html">ecEncCtx</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>salt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the peer salt of an <a class="el" href="structecEncCtx.html">ecEncCtx</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully setting the peer salt for the <a class="el" href="structecEncCtx.html">ecEncCtx</a> object. </dd>
<dd>
BAD_FUNC_ARG Returned if the given <a class="el" href="structecEncCtx.html">ecEncCtx</a> object is NULL or has an invalid protocol, or if the given salt is NULL </dd>
<dd>
BAD_ENC_STATE_E Returned if the <a class="el" href="structecEncCtx.html">ecEncCtx</a>'s state is ecSRV_SALT_GET or ecCLI_SALT_GET. In the latter two cases, this function also sets the <a class="el" href="structecEncCtx.html">ecEncCtx</a>'s state to ecSRV_BAD_STATE or ecCLI_BAD_STATE, respectively</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the <a class="el" href="structecEncCtx.html">ecEncCtx</a> for which to set the salt </td></tr>
    <tr><td class="paramname">salt</td><td>pointer to the peer's salt</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecEncCtx.html">ecEncCtx</a>* cliCtx, srvCtx;</div><div class="line">RNG rng;</div><div class="line"><span class="keyword">const</span> byte* cliSalt, srvSalt;</div><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line"></div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line">cliCtx = <a class="code" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe">wc_ecc_ctx_new</a>(REQ_RESP_CLIENT, &amp;rng);</div><div class="line">srvCtx = <a class="code" href="group__ECC.html#gafc55ff3a455341d143786e8a27c8bbbe">wc_ecc_ctx_new</a>(REQ_RESP_SERVER, &amp;rng);</div><div class="line"></div><div class="line">cliSalt = <a class="code" href="group__ECC.html#ga9fed993abfc221d34fafa5c7cab9f27e">wc_ecc_ctx_get_own_salt</a>(&amp;cliCtx);</div><div class="line">srvSalt = <a class="code" href="group__ECC.html#ga9fed993abfc221d34fafa5c7cab9f27e">wc_ecc_ctx_get_own_salt</a>(&amp;srvCtx);</div><div class="line">ret = <a class="code" href="group__ECC.html#ga6c20bea691ecc33b2e00f1ac5bf8ddeb">wc_ecc_ctx_set_peer_salt</a>(&amp;cliCtx, srvSalt);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga9fed993abfc221d34fafa5c7cab9f27e" title="This function returns the salt of an ecEncCtx object. This function should only be called when the ec...">wc_ecc_ctx_get_own_salt</a> </dd></dl>

</div>
</div>
<a id="ga1d79bc0005249de9da2ad9804aca27e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d79bc0005249de9da2ad9804aca27e6">&#9670;&nbsp;</a></span>wc_ecc_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_decrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>privKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>pubKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>msgSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>outSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecEncCtx.html">ecEncCtx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the <a class="el" href="structecEncCtx.html">ecEncCtx</a>'s encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully decrypting the input message </dd>
<dd>
BAD_FUNC_ARG Returned if privKey, pubKey, msg, msgSz, out, or outSz are NULL, or the ctx object specifies an unsupported encryption type </dd>
<dd>
BAD_ENC_STATE_E Returned if the ctx object given is in a state that is not appropriate for decryption </dd>
<dd>
BUFFER_E Returned if the supplied output buffer is too small to store the decrypted plaintext </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory for the shared secret key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privKey</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> object containing the private key to use for decryption </td></tr>
    <tr><td class="paramname">pubKey</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> object containing the public key of the peer with whom one wishes to communicate </td></tr>
    <tr><td class="paramname">msg</td><td>pointer to the buffer holding the ciphertext to decrypt </td></tr>
    <tr><td class="paramname">msgSz</td><td>size of the buffer to decrypt </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the decrypted plaintext </td></tr>
    <tr><td class="paramname">outSz</td><td>pointer to a word32 object containing the available size in the out buffer. Upon successfully decrypting the ciphertext, holds the number of bytes written to the output buffer </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional: pointer to an <a class="el" href="structecEncCtx.html">ecEncCtx</a> object specifying different decryption algorithms to use</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">byte cipher[] = { <span class="comment">// initialize with ciphertext to decrypt. Ensure padded to block size };</span></div><div class="line">byte plain[<span class="keyword">sizeof</span>(cipher)];</div><div class="line">word32 plainSz = <span class="keyword">sizeof</span>(plain);</div><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> cli, serv;</div><div class="line"><span class="comment">// initialize cli with private key</span></div><div class="line"><span class="comment">// initialize serv with received public key</span></div><div class="line"><a class="code" href="structecEncCtx.html">ecEncCtx</a>* cliCtx, servCtx;</div><div class="line"><span class="comment">// initialize cliCtx and servCtx</span></div><div class="line"><span class="comment">// exchange salts</span></div><div class="line">ret = <a class="code" href="group__ECC.html#ga1d79bc0005249de9da2ad9804aca27e6">wc_ecc_decrypt</a>(&amp;cli, &amp;serv, cipher, <span class="keyword">sizeof</span>(cipher), plain, &amp;plainSz, cliCtx);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(ret != 0) { </div><div class="line">    <span class="comment">// error decrypting message </span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>Wc_ecc_encrypt </dd></dl>

</div>
</div>
<a id="ga3992a20c8d2567a89e17bde7bc09ed09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3992a20c8d2567a89e17bde7bc09ed09">&#9670;&nbsp;</a></span>wc_ecc_del_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wc_ecc_del_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an ECC point from memory. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to free.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* point;</div><div class="line">point = <a class="code" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4">wc_ecc_new_point</a>();</div><div class="line"><span class="keywordflow">if</span> (point == NULL)</div><div class="line">{</div><div class="line">    <span class="comment">// Handle point creation error</span></div><div class="line">}</div><div class="line"><span class="comment">// Do stuff with point</span></div><div class="line"><a class="code" href="group__ECC.html#ga3992a20c8d2567a89e17bde7bc09ed09">wc_ecc_del_point</a>(point);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4" title="Allocate a new ECC point. ">wc_ecc_new_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga12592d79567f39f662708e71da8cb53e" title="Compare the value of a point with another one. ">wc_ecc_cmp_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga17ed1510ea50301ea021e820082eb7ba" title="Copy the value of one point to another one. ">wc_ecc_copy_point</a></dd></dl>
<p>Free an ECC point from memory p The point to free </p>

</div>
</div>
<a id="gaf5c0c73b9dd43f4101afdca32b9795b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5c0c73b9dd43f4101afdca32b9795b2">&#9670;&nbsp;</a></span>wc_ecc_encrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_encrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>privKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>pubKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>msgSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>outSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecEncCtx.html">ecEncCtx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function encrypts the given input message from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the <a class="el" href="structecEncCtx.html">ecEncCtx</a>'s encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully encrypting the input message </dd>
<dd>
BAD_FUNC_ARG Returned if privKey, pubKey, msg, msgSz, out, or outSz are NULL, or the ctx object specifies an unsupported encryption type </dd>
<dd>
BAD_ENC_STATE_E Returned if the ctx object given is in a state that is not appropriate for encryption </dd>
<dd>
BUFFER_E Returned if the supplied output buffer is too small to store the encrypted ciphertext </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory for the shared secret key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privKey</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> object containing the private key to use for encryption </td></tr>
    <tr><td class="paramname">pubKey</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> object containing the public key of the peer with whom one wishes to communicate </td></tr>
    <tr><td class="paramname">msg</td><td>pointer to the buffer holding the message to encrypt </td></tr>
    <tr><td class="paramname">msgSz</td><td>size of the buffer to encrypt </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the encrypted ciphertext </td></tr>
    <tr><td class="paramname">outSz</td><td>pointer to a word32 object containing the available size in the out buffer. Upon successfully encrypting the message, holds the number of bytes written to the output buffer </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional: pointer to an <a class="el" href="structecEncCtx.html">ecEncCtx</a> object specifying different encryption algorithms to use</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">byte msg[] = { <span class="comment">// initialize with msg to encrypt. Ensure padded to block size };</span></div><div class="line">byte out[<span class="keyword">sizeof</span>(msg)];</div><div class="line">word32 outSz = <span class="keyword">sizeof</span>(out);</div><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> cli, serv;</div><div class="line"><span class="comment">// initialize cli with private key</span></div><div class="line"><span class="comment">// initialize serv with received public key</span></div><div class="line"></div><div class="line"><a class="code" href="structecEncCtx.html">ecEncCtx</a>* cliCtx, servCtx;</div><div class="line"><span class="comment">// initialize cliCtx and servCtx</span></div><div class="line"><span class="comment">// exchange salts</span></div><div class="line">ret = <a class="code" href="group__ECC.html#gaf5c0c73b9dd43f4101afdca32b9795b2">wc_ecc_encrypt</a>(&amp;cli, &amp;serv, msg, <span class="keyword">sizeof</span>(msg), out, &amp;outSz, cliCtx);</div><div class="line"><span class="keywordflow">if</span>(ret != 0) { </div><div class="line">    <span class="comment">// error encrypting message </span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga1d79bc0005249de9da2ad9804aca27e6" title="This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as ...">wc_ecc_decrypt</a> </dd></dl>

</div>
</div>
<a id="ga45e4777dc90bb61b29dbdd8f9ef51b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45e4777dc90bb61b29dbdd8f9ef51b16">&#9670;&nbsp;</a></span>wc_ecc_export_point_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_export_point_der </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>curve_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>outLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export point to der. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on success. </dd>
<dd>
ECC_BAD_ARG_E Returns if curve_idx is less than 0 or invalid. Also returns when </dd>
<dd>
LENGTH_ONLY_E outLen is set but nothing else. </dd>
<dd>
BUFFER_E Returns if outLen is less than 1 + 2 * the curve size. </dd>
<dd>
MEMORY_E Returns if there is a problem allocating memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve_idx</td><td>Index of the curve used from ecc_sets. </td></tr>
    <tr><td class="paramname">point</td><td>Point to export to der. </td></tr>
    <tr><td class="paramname">out</td><td>Destination for the output. </td></tr>
    <tr><td class="paramname">outLen</td><td>Maxsize allowed for output, destination for final size of output</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> curve_idx;</div><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* point;</div><div class="line">byte out[];</div><div class="line">word32 outLen;</div><div class="line"><a class="code" href="group__ECC.html#ga45e4777dc90bb61b29dbdd8f9ef51b16">wc_ecc_export_point_der</a>(curve_idx, point, out, &amp;outLen);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gaae5216e693d446086fa1de57eef4d4a4" title="Import point from der format. ">wc_ecc_import_point_der</a> </dd></dl>

</div>
</div>
<a id="gac2a68cd1f5b6fc061d4c9f203446a56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a68cd1f5b6fc061d4c9f203446a56b">&#9670;&nbsp;</a></span>wc_ecc_export_private_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_export_private_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>outLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports only the private key from an <a class="el" href="structecc__key.html">ecc_key</a> structure. It stores the private key in the buffer out, and sets the bytes written to this buffer in outLen. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully exporting the private key </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input values evaluate to NULL </dd>
<dd>
MEMORY_E Returned if there is an error initializing space to store the parameters of the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
ASN_PARSE_E Returned if the input curveName is not defined in ecc_sets </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_READ_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_TO_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MEM may be returned if there is an error processing the input parameters</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to an <a class="el" href="structecc__key.html">ecc_key</a> structure from which to export the private key </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the private key </td></tr>
    <tr><td class="paramname">outLen</td><td>pointer to a word32 object with the size available in out. Set with the number of bytes written to out after successfully exporting the private key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><span class="comment">// initialize key, make key</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> priv[ECC_KEY_SIZE];</div><div class="line">word32 privSz = <span class="keyword">sizeof</span>(priv);</div><div class="line">ret = <a class="code" href="group__ECC.html#gac2a68cd1f5b6fc061d4c9f203446a56b">wc_ecc_export_private_only</a>(&amp;key, priv, &amp;privSz);</div><div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div><div class="line">    <span class="comment">// error exporting private key</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga5cf692ee35f6f8d9da48fe0fd9eacf9d" title="This function imports a public/private ECC key pair from a buffer containing the raw private key...">wc_ecc_import_private_key</a> </dd></dl>

</div>
</div>
<a id="gaebea0f5ac7cf38c4bf3d995b7047fa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebea0f5ac7cf38c4bf3d995b7047fa22">&#9670;&nbsp;</a></span>wc_ecc_export_x963()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_export_x963 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>outLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports the ECC key from the <a class="el" href="structecc__key.html">ecc_key</a> structure, storing the result in out. The key will be stored in ANSI X9.63 format. It stores the bytes written to the output buffer in outLen. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully exporting the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
LENGTH_ONLY_E Returned if the output buffer evaluates to NULL, but the other two input parameters are valid. Indicates that the function is only returning the length required to store the key </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input parameters are NULL, or the key is unsupported (has an invalid index) </dd>
<dd>
BUFFER_E Returned if the output buffer is too small to store the ecc key. If the output buffer is too small, the size needed will be returned in outLen </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_READ_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_TO_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MEM may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> object to export </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the ANSI X9.63 formatted key </td></tr>
    <tr><td class="paramname">outLen</td><td>size of the output buffer. On successfully storing the key, will hold the bytes written to the output buffer</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line">byte buff[1024];</div><div class="line">word32 buffSz = <span class="keyword">sizeof</span>(buff);</div><div class="line"></div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><span class="comment">// initialize key, make key</span></div><div class="line">ret = <a class="code" href="group__ECC.html#gaebea0f5ac7cf38c4bf3d995b7047fa22">wc_ecc_export_x963</a>(&amp;key, buff, &amp;buffSz);</div><div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div><div class="line">    <span class="comment">// error exporting key</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gae9bde81714fc7a024674171dd857e1b9" title="This function exports the ECC key from the ecc_key structure, storing the result in out...">wc_ecc_export_x963_ex</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga8121a4cfcd09c26eb12401ca82b4a56d" title="This function imports a public ECC key from a buffer containing the key stored in ANSI X9...">wc_ecc_import_x963</a> </dd></dl>

</div>
</div>
<a id="gae9bde81714fc7a024674171dd857e1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9bde81714fc7a024674171dd857e1b9">&#9670;&nbsp;</a></span>wc_ecc_export_x963_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_export_x963_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>outLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports the ECC key from the <a class="el" href="structecc__key.html">ecc_key</a> structure, storing the result in out. The key will be stored in ANSI X9.63 format. It stores the bytes written to the output buffer in outLen. This function allows the additional option of compressing the certificate through the compressed parameter. When this parameter is true, the key will be stored in ANSI X9.63 compressed format. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully exporting the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
NOT_COMPILED_IN Returned if the HAVE_COMP_KEY was not enabled at compile time, but the key was requested in compressed format </dd>
<dd>
LENGTH_ONLY_E Returned if the output buffer evaluates to NULL, but the other two input parameters are valid. Indicates that the function is only returning the length required to store the key </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input parameters are NULL, or the key is unsupported (has an invalid index) </dd>
<dd>
BUFFER_E Returned if the output buffer is too small to store the ecc key. If the output buffer is too small, the size needed will be returned in outLen </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_READ_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_TO_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MEM may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> object to export </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the ANSI X9.63 formatted key </td></tr>
    <tr><td class="paramname">outLen</td><td>size of the output buffer. On successfully storing the key, will hold the bytes written to the output buffer </td></tr>
    <tr><td class="paramname">compressed</td><td>indicator of whether to store the key in compressed format. 1==compressed, 0==uncompressed</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line">byte buff[1024];</div><div class="line">word32 buffSz = <span class="keyword">sizeof</span>(buff);</div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><span class="comment">// initialize key, make key</span></div><div class="line">ret = <a class="code" href="group__ECC.html#gae9bde81714fc7a024674171dd857e1b9">wc_ecc_export_x963_ex</a>(&amp;key, buff, &amp;buffSz, 1);</div><div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div><div class="line">    <span class="comment">// error exporting key</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gaebea0f5ac7cf38c4bf3d995b7047fa22" title="This function exports the ECC key from the ecc_key structure, storing the result in out...">wc_ecc_export_x963</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga8121a4cfcd09c26eb12401ca82b4a56d" title="This function imports a public ECC key from a buffer containing the key stored in ANSI X9...">wc_ecc_import_x963</a> </dd></dl>

</div>
</div>
<a id="gae4f69ab2fd9b5c89ba1ec7f65f5bccb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4f69ab2fd9b5c89ba1ec7f65f5bccb0">&#9670;&nbsp;</a></span>wc_ecc_fp_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wc_ecc_fp_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees the fixed-point cache, which can be used with ecc to speed up computation times. To use this functionality, FP_ECC (fixed-point ecc), should be defined. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><span class="comment">// initialize key and perform secure exchanges</span></div><div class="line">...</div><div class="line"></div><div class="line">wc_ecc_fp_free();</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gae8bd7d0557a101d940b70f144f9d7a97" title="This function frees an ecc_key object after it has been used. ">wc_ecc_free</a></dd></dl>
<p>Free the Fixed Point cache </p>

</div>
</div>
<a id="gae8bd7d0557a101d940b70f144f9d7a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8bd7d0557a101d940b70f144f9d7a97">&#9670;&nbsp;</a></span>wc_ecc_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API void wc_ecc_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees an <a class="el" href="structecc__key.html">ecc_key</a> object after it has been used. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> object to free</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="comment">// initialize key and perform secure exchanges</span></div><div class="line">...</div><div class="line">wc_ecc_free(&amp;key);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94" title="This function initializes an ecc_key object for future use with message verification or key negotiati...">wc_ecc_init</a></dd></dl>
<p>Free an ECC key from memory key The key you wish to free </p>

</div>
</div>
<a id="gaae5216e693d446086fa1de57eef4d4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae5216e693d446086fa1de57eef4d4a4">&#9670;&nbsp;</a></span>wc_ecc_import_point_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_import_point_der </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>curve_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import point from der format. </p>
<dl class="section return"><dt>Returns</dt><dd>ECC_BAD_ARG_E Returns if any arguments are null or if inLen is even. </dd>
<dd>
MEMORY_E Returns if there is an error initializing </dd>
<dd>
NOT_COMPILED_IN Returned if HAVE_COMP_KEY is not true and in is a compressed cert </dd>
<dd>
MP_OKAY Successful operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>der buffer to import point from. </td></tr>
    <tr><td class="paramname">inLen</td><td>Length of der buffer. </td></tr>
    <tr><td class="paramname">curve_idx</td><td>Index of curve. </td></tr>
    <tr><td class="paramname">point</td><td>Destination for point.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">byte in[];</div><div class="line">word32 inLen;</div><div class="line"><span class="keywordtype">int</span> curve_idx;</div><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* point;</div><div class="line"><a class="code" href="group__ECC.html#gaae5216e693d446086fa1de57eef4d4a4">wc_ecc_import_point_der</a>(in, inLen, curve_idx, point);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga45e4777dc90bb61b29dbdd8f9ef51b16" title="Export point to der. ">wc_ecc_export_point_der</a> </dd></dl>

</div>
</div>
<a id="ga5cf692ee35f6f8d9da48fe0fd9eacf9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cf692ee35f6f8d9da48fe0fd9eacf9d">&#9670;&nbsp;</a></span>wc_ecc_import_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_import_private_key </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>priv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>privSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>pub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>pubSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function imports a public/private ECC key pair from a buffer containing the raw private key, and a second buffer containing the ANSI X9.63 formatted public key. This function will handle both compressed and uncompressed keys, as long as compressed keys are enabled at compile time through the HAVE_COMP_KEY option. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully importing the <a class="el" href="structecc__key.html">ecc_key</a> NOT_COMPILED_IN Returned if the HAVE_COMP_KEY was not enabled at compile time, but the key is stored in compressed format </dd>
<dd>
ECC_BAD_ARG_E Returned if in or key evaluate to NULL, or the inLen is even (according to the x9.63 standard, the key must be odd) </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the ECC key; may indicate that the ECC key is not stored in valid ANSI X9.63 format </dd>
<dd>
IS_POINT_E Returned if the public key exported is not a point on the ECC curve </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_READ_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_TO_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MEM may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priv</td><td>pointer to the buffer containing the raw private key </td></tr>
    <tr><td class="paramname">privSz</td><td>size of the private key buffer </td></tr>
    <tr><td class="paramname">pub</td><td>pointer to the buffer containing the ANSI x9.63 formatted ECC public key </td></tr>
    <tr><td class="paramname">pubSz</td><td>length of the public key input buffer </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> object in which to store the imported private/public key pair <pre class="fragment">_Example_
</pre> <div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line">byte pub[] = { <span class="comment">// initialize with ANSI X9.63 formatted key };</span></div><div class="line">byte priv[] = { <span class="comment">// initialize with the raw private key };</span></div><div class="line"></div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line">wc_ecc_init_key(&amp;key);</div><div class="line">ret = <a class="code" href="group__ECC.html#ga5cf692ee35f6f8d9da48fe0fd9eacf9d">wc_ecc_import_private_key</a>(priv, <span class="keyword">sizeof</span>(priv), pub, <span class="keyword">sizeof</span>(pub), &amp;key);</div><div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div><div class="line">    <span class="comment">// error importing key</span></div><div class="line">}</div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gaebea0f5ac7cf38c4bf3d995b7047fa22" title="This function exports the ECC key from the ecc_key structure, storing the result in out...">wc_ecc_export_x963</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga5cf692ee35f6f8d9da48fe0fd9eacf9d" title="This function imports a public/private ECC key pair from a buffer containing the raw private key...">wc_ecc_import_private_key</a> </dd></dl>

</div>
</div>
<a id="gab3527442083c437ed706308c8be95b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3527442083c437ed706308c8be95b59">&#9670;&nbsp;</a></span>wc_ecc_import_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_import_raw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>qx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>qy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>curveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fills an <a class="el" href="structecc__key.html">ecc_key</a> structure with the raw components of an ECC signature. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully importing into the <a class="el" href="structecc__key.html">ecc_key</a> structure </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input values evaluate to NULL </dd>
<dd>
MEMORY_E Returned if there is an error initializing space to store the parameters of the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
ASN_PARSE_E Returned if the input curveName is not defined in ecc_sets </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_READ_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_TO_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MEM may be returned if there is an error processing the input parameters</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to an <a class="el" href="structecc__key.html">ecc_key</a> structure to fill </td></tr>
    <tr><td class="paramname">qx</td><td>pointer to a buffer containing the x component of the base point as an ASCII hex string </td></tr>
    <tr><td class="paramname">qy</td><td>pointer to a buffer containing the y component of the base point as an ASCII hex string </td></tr>
    <tr><td class="paramname">d</td><td>pointer to a buffer containing the private key as an ASCII hex string </td></tr>
    <tr><td class="paramname">curveName</td><td>pointer to a string containing the ECC curve name, as found in ecc_sets</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><a class="code" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94">wc_ecc_init</a>(&amp;key);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> qx[] = { <span class="comment">// initialize with x component of base point };</span></div><div class="line"><span class="keywordtype">char</span> qy[] = { <span class="comment">// initialize with y component of base point };</span></div><div class="line"><span class="keywordtype">char</span> d[]  = { <span class="comment">// initialize with private key };</span></div><div class="line">ret = <a class="code" href="group__ECC.html#gab3527442083c437ed706308c8be95b59">wc_ecc_import_raw</a>(&amp;key,qx, qy, d, <span class="stringliteral">&quot;ECC-256&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div><div class="line">    <span class="comment">// error initializing key with given inputs</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga5cf692ee35f6f8d9da48fe0fd9eacf9d" title="This function imports a public/private ECC key pair from a buffer containing the raw private key...">wc_ecc_import_private_key</a></dd></dl>
<p>Import raw ECC key key The destination <a class="el" href="structecc__key.html">ecc_key</a> structure qx x component of the public key, as ASCII hex string qy y component of the public key, as ASCII hex string d private key, as ASCII hex string, optional if importing public key only curveName ECC curve name, from ecc_sets[] return MP_OKAY on success </p>

</div>
</div>
<a id="ga8121a4cfcd09c26eb12401ca82b4a56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8121a4cfcd09c26eb12401ca82b4a56d">&#9670;&nbsp;</a></span>wc_ecc_import_x963()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_import_x963 </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function imports a public ECC key from a buffer containing the key stored in ANSI X9.63 format. This function will handle both compressed and uncompressed keys, as long as compressed keys are enabled at compile time through the HAVE_COMP_KEY option. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully importing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
NOT_COMPILED_IN Returned if the HAVE_COMP_KEY was not enabled at compile time, but the key is stored in compressed format </dd>
<dd>
ECC_BAD_ARG_E Returned if in or key evaluate to NULL, or the inLen is even (according to the x9.63 standard, the key must be odd) </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the ECC key; may indicate that the ECC key is not stored in valid ANSI X9.63 format </dd>
<dd>
IS_POINT_E Returned if the public key exported is not a point on the ECC curve </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_READ_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_TO_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MEM may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer containing the ANSI x9.63 formatted ECC key </td></tr>
    <tr><td class="paramname">inLen</td><td>length of the input buffer </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> object in which to store the imported key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line">byte buff[] = { <span class="comment">// initialize with ANSI X9.63 formatted key };</span></div><div class="line"></div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> pubKey;</div><div class="line">wc_ecc_init_key(&amp;pubKey);</div><div class="line"></div><div class="line">ret = <a class="code" href="group__ECC.html#ga8121a4cfcd09c26eb12401ca82b4a56d">wc_ecc_import_x963</a>(buff, <span class="keyword">sizeof</span>(buff), &amp;pubKey);</div><div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div><div class="line">    <span class="comment">// error importing key</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gaebea0f5ac7cf38c4bf3d995b7047fa22" title="This function exports the ECC key from the ecc_key structure, storing the result in out...">wc_ecc_export_x963</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga5cf692ee35f6f8d9da48fe0fd9eacf9d" title="This function imports a public/private ECC key pair from a buffer containing the raw private key...">wc_ecc_import_private_key</a> </dd></dl>

</div>
</div>
<a id="gaa32dc4d612f1b9385d9276a2370d6d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa32dc4d612f1b9385d9276a2370d6d94">&#9670;&nbsp;</a></span>wc_ecc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes an <a class="el" href="structecc__key.html">ecc_key</a> object for future use with message verification or key negotiation. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully initializing the <a class="el" href="structecc__key.html">ecc_key</a> object </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> object to initialize</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><a class="code" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94">wc_ecc_init</a>(&amp;key);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gad510edd30f492a95fe70b3f8588362e8" title="This function generates a new ecc_key and stores it in key. ">wc_ecc_make_key</a> </dd>
<dd>
<a class="el" href="group__ECC.html#gae8bd7d0557a101d940b70f144f9d7a97" title="This function frees an ecc_key object after it has been used. ">wc_ecc_free</a> </dd></dl>

</div>
</div>
<a id="ga3ca84e578ae39aca382a05b8aabf8877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ca84e578ae39aca382a05b8aabf8877">&#9670;&nbsp;</a></span>wc_ecc_is_valid_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_is_valid_idx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an ECC idx is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>1 Return if valid. </dd>
<dd>
0 Return if not valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The idx number to check.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line">RNG rng;</div><div class="line"><span class="keywordtype">int</span> is_valid;</div><div class="line"><a class="code" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94">wc_ecc_init</a>(&amp;key);</div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line"><a class="code" href="group__ECC.html#gad510edd30f492a95fe70b3f8588362e8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key);</div><div class="line">is_valid = <a class="code" href="group__ECC.html#ga3ca84e578ae39aca382a05b8aabf8877">wc_ecc_is_valid_idx</a>(key.idx);</div><div class="line"><span class="keywordflow">if</span> (is_valid == 1)</div><div class="line">{</div><div class="line">    <span class="comment">// idx is valid</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_valid == 0)</div><div class="line">{</div><div class="line">    <span class="comment">// idx is not valid</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none</dd></dl>
<p>Returns whether an ECC idx is valid or not n The idx number to check return 1 if valid, 0 if not </p>

</div>
</div>
<a id="gad510edd30f492a95fe70b3f8588362e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad510edd30f492a95fe70b3f8588362e8">&#9670;&nbsp;</a></span>wc_ecc_make_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_make_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWC__RNG.html">WC_RNG</a> *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a new <a class="el" href="structecc__key.html">ecc_key</a> and stores it in key. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on success. </dd>
<dd>
ECC_BAD_ARG_E Returned if rng or key evaluate to NULL </dd>
<dd>
BAD_FUNC_ARG Returned if the specified key size is not in the correct range of supported keys </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory while computing the ecc key </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MEM may be returned if there is an error while computing the ecc key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>pointer to an initialized RNG object with which to generate the key </td></tr>
    <tr><td class="paramname">keysize</td><td>desired length for the <a class="el" href="structecc__key.html">ecc_key</a> </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> for which to generate a key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><a class="code" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94">wc_ecc_init</a>(&amp;key);</div><div class="line">RNG rng;</div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng);</div><div class="line"><a class="code" href="group__ECC.html#gad510edd30f492a95fe70b3f8588362e8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key); <span class="comment">// initialize 32 byte ecc key</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94" title="This function initializes an ecc_key object for future use with message verification or key negotiati...">wc_ecc_init</a> </dd>
<dd>
<a class="el" href="group__ECC.html#gab92c015b38d6f61f339e7412500dcf83" title="This function generates a new secret key using a local private key and a received public key...">wc_ecc_shared_secret</a></dd></dl>
<p>Make a new ECC key rng An active RNG state keysize The keysize for the new key (in octets from 20 to 65 bytes) key [out] Destination of the newly created key return MP_OKAY if successful, upon error all allocated memory will be freed </p>

</div>
</div>
<a id="gacd60b6f104018b22af7a7700a676e057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd60b6f104018b22af7a7700a676e057">&#9670;&nbsp;</a></span>wc_ecc_mulmod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_mulmod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmp__int.html">mp_int</a> *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmp__int.html">mp_int</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmp__int.html">mp_int</a> *&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform ECC Fixed Point multiplication. </p>
<dl class="section return"><dt>Returns</dt><dd>MP_OKAY Returns on successful operation. </dd>
<dd>
MP_INIT_E Returned if there is an error initializing an integer for use with the multiple precision integer (<a class="el" href="structmp__int.html">mp_int</a>) library.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The multiplicand. </td></tr>
    <tr><td class="paramname">G</td><td>Base point to multiply. </td></tr>
    <tr><td class="paramname">R</td><td>Destination of product. </td></tr>
    <tr><td class="paramname">modulus</td><td>The modulus for the curve. </td></tr>
    <tr><td class="paramname">map</td><td>If non-zero maps the point back to affine coordinates, otherwise it's left in jacobian-montgomery form.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* base;</div><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* destination;</div><div class="line"><span class="comment">// Initialize points</span></div><div class="line">base = <a class="code" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4">wc_ecc_new_point</a>();</div><div class="line">destination = <a class="code" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4">wc_ecc_new_point</a>();</div><div class="line"><span class="comment">// Setup other arguments</span></div><div class="line"><a class="code" href="structmp__int.html">mp_int</a> multiplicand;</div><div class="line"><a class="code" href="structmp__int.html">mp_int</a> modulus;</div><div class="line"><span class="keywordtype">int</span> map;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__ECC.html#gacd60b6f104018b22af7a7700a676e057">wc_ecc_mulmod</a>(&amp;multiplicand, base, destination, &amp;modulus, map) == MP_OKAY)</div><div class="line">{</div><div class="line">    <span class="comment">// Successful operation</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none</dd></dl>
<p>ECC Fixed Point mulmod global k The multiplicand G Base point to multiply R [out] Destination of product a ECC curve parameter a modulus The modulus for the curve map [boolean] If non-zero maps the point back to affine co-ordinates, otherwise it's left in jacobian-montgomery form return MP_OKAY if successful </p>

</div>
</div>
<a id="ga875fb9dc7833d12d5f2661a8ba1880a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga875fb9dc7833d12d5f2661a8ba1880a4">&#9670;&nbsp;</a></span>wc_ecc_new_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API <a class="el" href="structecc__point.html">ecc_point</a>* wc_ecc_new_point </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new ECC point. </p>
<dl class="section return"><dt>Returns</dt><dd>p A newly allocated point. </dd>
<dd>
NULL Returns NULL on error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* point;</div><div class="line">point = <a class="code" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4">wc_ecc_new_point</a>();</div><div class="line"><span class="keywordflow">if</span> (point == NULL)</div><div class="line">{</div><div class="line">    <span class="comment">// Handle point creation error</span></div><div class="line">}</div><div class="line"><span class="comment">// Do stuff with point</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga3992a20c8d2567a89e17bde7bc09ed09" title="Free an ECC point from memory. ">wc_ecc_del_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga12592d79567f39f662708e71da8cb53e" title="Compare the value of a point with another one. ">wc_ecc_cmp_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga17ed1510ea50301ea021e820082eb7ba" title="Copy the value of one point to another one. ">wc_ecc_copy_point</a></dd></dl>
<p>Allocate a new ECC point return A newly allocated point or NULL on error </p>

</div>
</div>
<a id="ga2753e5e519730482314f381ebcf7a6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2753e5e519730482314f381ebcf7a6c2">&#9670;&nbsp;</a></span>wc_ecc_point_is_at_infinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_point_is_at_infinity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a point is at infinity. Returns 1 if point is at infinity, 0 if not, &lt; 0 on error. </p>
<dl class="section return"><dt>Returns</dt><dd>1 p is at infinity. </dd>
<dd>
0 p is not at infinity. </dd>
<dd>
&lt;0 Error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to check.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* point;</div><div class="line"><span class="keywordtype">int</span> is_infinity;</div><div class="line">point = <a class="code" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4">wc_ecc_new_point</a>();</div><div class="line"></div><div class="line">is_infinity = <a class="code" href="group__ECC.html#ga2753e5e519730482314f381ebcf7a6c2">wc_ecc_point_is_at_infinity</a>(point);</div><div class="line"><span class="keywordflow">if</span> (is_infinity &lt; 0)</div><div class="line">{</div><div class="line">    <span class="comment">// Handle error</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_infinity == 0)</div><div class="line">{</div><div class="line">    <span class="comment">// Point is not at infinity</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_infinity == 1)</div><div class="line">{</div><div class="line">    <span class="comment">// Point is at infinity</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4" title="Allocate a new ECC point. ">wc_ecc_new_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga3992a20c8d2567a89e17bde7bc09ed09" title="Free an ECC point from memory. ">wc_ecc_del_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga12592d79567f39f662708e71da8cb53e" title="Compare the value of a point with another one. ">wc_ecc_cmp_point</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga17ed1510ea50301ea021e820082eb7ba" title="Copy the value of one point to another one. ">wc_ecc_copy_point</a> </dd></dl>

</div>
</div>
<a id="ga8670c34f6078bad922140c8b933969d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8670c34f6078bad922140c8b933969d0">&#9670;&nbsp;</a></span>wc_ecc_rs_to_sig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_rs_to_sig </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the R and S portions of an ECC signature into a DER-encoded ECDSA signature. This function also stores the length written to the output buffer, out, in outlen. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully converting the signature </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input parameters evaluate to NULL, or if the input buffer is not large enough to hold the DER-encoded ECDSA signature </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_READ_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_TO_E may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a> </dd>
<dd>
MP_MEM may be returned if there is an error processing the <a class="el" href="structecc__key.html">ecc_key</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the buffer containing the R portion of the signature as a string </td></tr>
    <tr><td class="paramname">s</td><td>pointer to the buffer containing the S portion of the signature as a string </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the DER-encoded ECDSA signature </td></tr>
    <tr><td class="paramname">outlen</td><td>length of the output buffer available. Will store the bytes written to the buffer after successfully converting the signature to ECDSA format</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><span class="comment">// initialize key, generate R and S</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> r[] = { <span class="comment">// initialize with R };</span></div><div class="line"><span class="keywordtype">char</span> s[] = { <span class="comment">// initialize with S };</span></div><div class="line">byte sig[<a class="code" href="group__ECC.html#gaf181e4ceefcf3e5ad05d16aeeaa6dc6c">wc_ecc_sig_size</a>(key)]; </div><div class="line"><span class="comment">// signature size will be 2 * ECC key size + ~10 bytes for ASN.1 overhead</span></div><div class="line">word32 sigSz = <span class="keyword">sizeof</span>(sig);</div><div class="line">ret = <a class="code" href="group__ECC.html#ga8670c34f6078bad922140c8b933969d0">wc_ecc_rs_to_sig</a>(r, s, sig, &amp;sigSz);</div><div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div><div class="line">    <span class="comment">// error converting parameters to signature</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga0de1f56d50dcd1eb684a0e2a45eebf27" title="This function signs a message digest using an ecc_key object to guarantee authenticity. ">wc_ecc_sign_hash</a> </dd>
<dd>
<a class="el" href="group__ECC.html#gaf181e4ceefcf3e5ad05d16aeeaa6dc6c" title="This function returns the worst case size for an ECC signature, given by: keySz * 2 + SIG_HEADER_SZ +...">wc_ecc_sig_size</a></dd></dl>
<p>Convert ECC R,S to signature r R component of signature s S component of signature out DER-encoded ECDSA signature outlen [in/out] output buffer size, output signature size return MP_OKAY on success </p>

</div>
</div>
<a id="gab92c015b38d6f61f339e7412500dcf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab92c015b38d6f61f339e7412500dcf83">&#9670;&nbsp;</a></span>wc_ecc_shared_secret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_shared_secret </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>private_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a new secret key using a local private key and a received public key. It stores this shared secret key in the buffer out and updates outlen to hold the number of bytes written to the output buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully generating a shared secret key </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input parameters evaluate to NULL </dd>
<dd>
ECC_BAD_ARG_E Returned if the type of the private key given as argument, private_key, is not ECC_PRIVATEKEY, or if the public and private key types (given by ecc-&gt;dp) are not equivalent </dd>
<dd>
MEMORY_E Returned if there is an error generating a new ecc point </dd>
<dd>
BUFFER_E Returned if the generated shared secret key is too long to store in the provided buffer </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_MEM may be returned if there is an error while computing the shared key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">private_key</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> structure containing the local private key </td></tr>
    <tr><td class="paramname">public_key</td><td>pointer to the <a class="el" href="structecc__key.html">ecc_key</a> structure containing the received public key </td></tr>
    <tr><td class="paramname">out</td><td>pointer to an output buffer in which to store the generated shared secret key </td></tr>
    <tr><td class="paramname">outlen</td><td>pointer to the word32 object containing the length of the output buffer. Will be overwritten with the length written to the output buffer upon successfully generating a shared secret key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> priv, pub;</div><div class="line">RNG rng;</div><div class="line">byte secret[1024]; <span class="comment">// can hold 1024 byte shared secret key</span></div><div class="line">word32 secretSz = <span class="keyword">sizeof</span>(secret);</div><div class="line"><span class="keywordtype">int</span> ret;</div><div class="line"></div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng); <span class="comment">// initialize rng</span></div><div class="line"><a class="code" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94">wc_ecc_init</a>(&amp;priv); <span class="comment">// initialize key</span></div><div class="line"><a class="code" href="group__ECC.html#gad510edd30f492a95fe70b3f8588362e8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;priv); <span class="comment">// make public/private key pair</span></div><div class="line"><span class="comment">// receive public key, and initialise into pub</span></div><div class="line">ret = <a class="code" href="group__ECC.html#gab92c015b38d6f61f339e7412500dcf83">wc_ecc_shared_secret</a>(&amp;priv, &amp;pub, secret, &amp;secretSz); <span class="comment">// generate secret key</span></div><div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div><div class="line">    <span class="comment">// error generating shared secret key</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94" title="This function initializes an ecc_key object for future use with message verification or key negotiati...">wc_ecc_init</a> </dd>
<dd>
<a class="el" href="group__ECC.html#gad510edd30f492a95fe70b3f8588362e8" title="This function generates a new ecc_key and stores it in key. ">wc_ecc_make_key</a></dd></dl>
<p>Create an ECC shared secret between two keys private_key The private ECC key (heap hint based off of private key) public_key The public key out [out] Destination of the shared secret Conforms to EC-DH from ANSI X9.63 outlen [in/out] The max size and resulting size of the shared secret return MP_OKAY if successful </p>

</div>
</div>
<a id="ga5218fab8c7043ed4d64dc34e8d2bd9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5218fab8c7043ed4d64dc34e8d2bd9d5">&#9670;&nbsp;</a></span>wc_ecc_shared_secret_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_shared_secret_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>private_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__point.html">ecc_point</a> *&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ECC shared secret between private key and public point. </p>
<dl class="section return"><dt>Returns</dt><dd>MP_OKAY Indicates success. </dd>
<dd>
BAD_FUNC_ARG Error returned when any arguments are null. </dd>
<dd>
ECC_BAD_ARG_E Error returned if private_key-&gt;type is not ECC_PRIVATEKEY or private_key-&gt;idx fails to validate. </dd>
<dd>
BUFFER_E Error when outlen is too small. </dd>
<dd>
MEMORY_E Error to create a new point. </dd>
<dd>
MP_VAL possible when an initialization failure occurs. </dd>
<dd>
MP_MEM possible when an initialization failure occurs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">private_key</td><td>The private ECC key. </td></tr>
    <tr><td class="paramname">point</td><td>The point to use (public key). </td></tr>
    <tr><td class="paramname">out</td><td>Output destination of the shared secret. Conforms to EC-DH from ANSI X9.63. </td></tr>
    <tr><td class="paramname">outlen</td><td>Input the max size and output the resulting size of the shared secret.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><a class="code" href="structecc__point.html">ecc_point</a>* point;</div><div class="line">byte shared_secret[];</div><div class="line"><span class="keywordtype">int</span> secret_size;</div><div class="line"><span class="keywordtype">int</span> result;</div><div class="line"></div><div class="line">point = <a class="code" href="group__ECC.html#ga875fb9dc7833d12d5f2661a8ba1880a4">wc_ecc_new_point</a>();</div><div class="line"></div><div class="line">result = wc_ecc_shared_secret_ssh(&amp;key, point, &amp;shared_secret, &amp;secret_size);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (result != MP_OKAY)</div><div class="line">{</div><div class="line">    <span class="comment">// Handle error</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga24071ff7fd61458687dfd13f5129fdaa" title="Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the re...">wc_ecc_verify_hash_ex</a></dd></dl>
<p>Create an ECC shared secret between private key and public point private_key The private ECC key (heap hint based on private key) point The point to use (public key) out [out] Destination of the shared secret Conforms to EC-DH from ANSI X9.63 outlen [in/out] The max size and resulting size of the shared secret return MP_OKAY if successful </p>

</div>
</div>
<a id="gaf181e4ceefcf3e5ad05d16aeeaa6dc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf181e4ceefcf3e5ad05d16aeeaa6dc6c">&#9670;&nbsp;</a></span>wc_ecc_sig_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_sig_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the worst case size for an ECC signature, given by: keySz * 2 + SIG_HEADER_SZ + 4 The actual signature size can be computed with wc_ecc_sign_hash. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Given a valid key, returns the maximum signature size, in octets </dd>
<dd>
0 Returned if the given key is NULL</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to an <a class="el" href="structecc__key.html">ecc_key</a> structure for which to get the signature size</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sigSz;</div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><span class="comment">// initialize key, make key</span></div><div class="line"></div><div class="line">sigSz = <a class="code" href="group__ECC.html#gaf181e4ceefcf3e5ad05d16aeeaa6dc6c">wc_ecc_sig_size</a>(&amp;key);</div><div class="line"><span class="keywordflow">if</span> ( sigSz == 0) {</div><div class="line">    <span class="comment">// error determining sig size</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga0de1f56d50dcd1eb684a0e2a45eebf27" title="This function signs a message digest using an ecc_key object to guarantee authenticity. ">wc_ecc_sign_hash</a> </dd></dl>

</div>
</div>
<a id="ga0de1f56d50dcd1eb684a0e2a45eebf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0de1f56d50dcd1eb684a0e2a45eebf27">&#9670;&nbsp;</a></span>wc_ecc_sign_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_sign_hash </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *&#160;</td>
          <td class="paramname"><em>outlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWC__RNG.html">WC_RNG</a> *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function signs a message digest using an <a class="el" href="structecc__key.html">ecc_key</a> object to guarantee authenticity. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully generating a signature for the message digest </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input parameters evaluate to NULL, or if the output buffer is too small to store the generated signature </dd>
<dd>
ECC_BAD_ARG_E Returned if the input key is not a private key, or if the ECC OID is invalid </dd>
<dd>
RNG_FAILURE_E Returned if the rng cannot successfully generate a satisfactory key </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MEM may be returned if there is an error while computing the message signature</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer containing the message hash to sign </td></tr>
    <tr><td class="paramname">inlen</td><td>length of the message hash to sign </td></tr>
    <tr><td class="paramname">out</td><td>buffer in which to store the generated signature </td></tr>
    <tr><td class="paramname">outlen</td><td>max length of the output buffer. Will store the bytes written to out upon successfully generating a message signature </td></tr>
    <tr><td class="paramname">key</td><td>pointer to a private ECC key with which to generate the signature</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line">RNG rng;</div><div class="line"><span class="keywordtype">int</span> ret, sigSz;</div><div class="line"></div><div class="line">byte sig[512]; <span class="comment">// will hold generated signature</span></div><div class="line">sigSz = <span class="keyword">sizeof</span>(sig);</div><div class="line">byte digest[] = { <span class="comment">// initialize with message hash };</span></div><div class="line"><a class="code" href="group__Random.html#gaebcb2bd505879f9080396a04ad990898">wc_InitRng</a>(&amp;rng); <span class="comment">// initialize rng</span></div><div class="line"><a class="code" href="group__ECC.html#gaa32dc4d612f1b9385d9276a2370d6d94">wc_ecc_init</a>(&amp;key); <span class="comment">// initialize key</span></div><div class="line"><a class="code" href="group__ECC.html#gad510edd30f492a95fe70b3f8588362e8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key); <span class="comment">// make public/private key pair</span></div><div class="line">ret = <a class="code" href="group__ECC.html#ga0de1f56d50dcd1eb684a0e2a45eebf27">wc_ecc_sign_hash</a>(digest, <span class="keyword">sizeof</span>(digest), sig, &amp;sigSz, &amp;key);</div><div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div><div class="line">    <span class="comment">// error generating message signature</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga89c60fc76d5566f23f73f43d31f29fe0" title="This function verifies the ECC signature of a hash to ensure authenticity. It returns the answer thro...">wc_ecc_verify_hash</a></dd></dl>
<p>Sign a message digest in The message digest to sign inlen The length of the digest out [out] The destination for the signature outlen [in/out] The max size and resulting size of the signature key A private ECC key return MP_OKAY if successful </p>

</div>
</div>
<a id="ga10a2f2f85cf87e05dcc6077ea26c7f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10a2f2f85cf87e05dcc6077ea26c7f25">&#9670;&nbsp;</a></span>wc_ecc_sign_hash_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_sign_hash_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWC__RNG.html">WC_RNG</a> *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmp__int.html">mp_int</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmp__int.html">mp_int</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign a message digest. </p>
<dl class="section return"><dt>Returns</dt><dd>MP_OKAY Returned upon successfully generating a signature for the message digest </dd>
<dd>
ECC_BAD_ARG_E Returned if the input key is not a private key, or if the ECC IDX is invalid, or if any of the input parameters evaluate to NULL, or if the output buffer is too small to store the generated signature </dd>
<dd>
RNG_FAILURE_E Returned if the rng cannot successfully generate a satisfactory key </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MEM may be returned if there is an error while computing the message signature</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The message digest to sign. </td></tr>
    <tr><td class="paramname">inlen</td><td>The length of the digest. </td></tr>
    <tr><td class="paramname">rng</td><td>Pointer to <a class="el" href="structWC__RNG.html">WC_RNG</a> struct. </td></tr>
    <tr><td class="paramname">key</td><td>A private ECC key. </td></tr>
    <tr><td class="paramname">r</td><td>The destination for r component of the signature. </td></tr>
    <tr><td class="paramname">s</td><td>The destination for s component of the signature.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><a class="code" href="structWC__RNG.html">WC_RNG</a> rng;</div><div class="line"><span class="keywordtype">int</span> ret, sigSz;</div><div class="line"><a class="code" href="structmp__int.html">mp_int</a> r; <span class="comment">// destination for r component of signature.</span></div><div class="line"><a class="code" href="structmp__int.html">mp_int</a> s; <span class="comment">// destination for s component of signature.</span></div><div class="line"></div><div class="line">byte sig[512]; <span class="comment">// will hold generated signature</span></div><div class="line">sigSz = <span class="keyword">sizeof</span>(sig);</div><div class="line">byte digest[] = { <span class="comment">/* initialize with message hash };</span></div><div class="line"><span class="comment">wc_InitRng(&amp;rng); // initialize rng</span></div><div class="line"><span class="comment">wc_ecc_init(&amp;key); // initialize key</span></div><div class="line"><span class="comment">wc_ecc_make_key(&amp;rng, 32, &amp;key); // make public/private key pair</span></div><div class="line"><span class="comment">ret = wc_ecc_sign_hash_ex(digest, sizeof(digest), &amp;rng, &amp;key, &amp;r, &amp;s);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">if ( ret != MP_OKAY ) {</span></div><div class="line"><span class="comment">    // error generating message signature</span></div><div class="line"><span class="comment">}</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga24071ff7fd61458687dfd13f5129fdaa" title="Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the re...">wc_ecc_verify_hash_ex</a></dd></dl>
<p>Sign a message digest in The message digest to sign inlen The length of the digest key A private ECC key r [out] The destination for r component of the signature s [out] The destination for s component of the signature return MP_OKAY if successful </p>

</div>
</div>
<a id="ga98fe576e4be2e211ae687520bbf54cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98fe576e4be2e211ae687520bbf54cd8">&#9670;&nbsp;</a></span>wc_ecc_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the key size of an <a class="el" href="structecc__key.html">ecc_key</a> structure in octets. </p>
<dl class="section return"><dt>Returns</dt><dd>Given a valid key, returns the key size in octets </dd>
<dd>
0 Returned if the given key is NULL</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to an <a class="el" href="structecc__key.html">ecc_key</a> structure for which to get the key size</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> keySz;</div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><span class="comment">// initialize key, make key</span></div><div class="line">keySz = <a class="code" href="group__ECC.html#ga98fe576e4be2e211ae687520bbf54cd8">wc_ecc_size</a>(&amp;key);</div><div class="line"><span class="keywordflow">if</span> ( keySz == 0) {</div><div class="line">    <span class="comment">// error determining key size</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#gad510edd30f492a95fe70b3f8588362e8" title="This function generates a new ecc_key and stores it in key. ">wc_ecc_make_key</a> </dd></dl>

</div>
</div>
<a id="ga89c60fc76d5566f23f73f43d31f29fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89c60fc76d5566f23f73f43d31f29fe0">&#9670;&nbsp;</a></span>wc_ecc_verify_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_verify_hash </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>siglen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>hashlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function verifies the ECC signature of a hash to ensure authenticity. It returns the answer through stat, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully performing the signature verification. Note: This does not mean that the signature is verified. The authenticity information is stored instead in stat </dd>
<dd>
BAD_FUNC_ARG Returned any of the input parameters evaluate to NULL </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MEM may be returned if there is an error while computing the message signature</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>pointer to the buffer containing the signature to verify </td></tr>
    <tr><td class="paramname">siglen</td><td>length of the signature to verify </td></tr>
    <tr><td class="paramname">hash</td><td>pointer to the buffer containing the hash of the message verified </td></tr>
    <tr><td class="paramname">hashlen</td><td>length of the hash of the message verified </td></tr>
    <tr><td class="paramname">stat</td><td>pointer to the result of the verification. 1 indicates the message was successfully verified </td></tr>
    <tr><td class="paramname">key</td><td>pointer to a public ECC key with which to verify the signature</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"><span class="keywordtype">int</span> ret, verified = 0;</div><div class="line"></div><div class="line">byte sig[1024] { <span class="comment">// initialize with received signature };</span></div><div class="line">byte digest[] = { <span class="comment">// initialize with message hash };</span></div><div class="line"><span class="comment">// initialize key with received public key</span></div><div class="line">ret = <a class="code" href="group__ECC.html#ga89c60fc76d5566f23f73f43d31f29fe0">wc_ecc_verify_hash</a>(sig, <span class="keyword">sizeof</span>(sig), digest,<span class="keyword">sizeof</span>(digest), &amp;verified, &amp;key);</div><div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div><div class="line">    <span class="comment">// error performing verification</span></div><div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( verified == 0 ) {</div><div class="line">    <span class="comment">// the signature is invalid</span></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga0de1f56d50dcd1eb684a0e2a45eebf27" title="This function signs a message digest using an ecc_key object to guarantee authenticity. ">wc_ecc_sign_hash</a> </dd>
<dd>
<a class="el" href="group__ECC.html#ga24071ff7fd61458687dfd13f5129fdaa" title="Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the re...">wc_ecc_verify_hash_ex</a></dd></dl>
<p>Verify an ECC signature sig The signature to verify siglen The length of the signature (octets) hash The hash (message digest) that was signed hashlen The length of the hash (octets) res Result of signature, 1==valid, 0==invalid key The corresponding public ECC key return MP_OKAY if successful (even if the signature is not valid) </p>

</div>
</div>
<a id="ga24071ff7fd61458687dfd13f5129fdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24071ff7fd61458687dfd13f5129fdaa">&#9670;&nbsp;</a></span>wc_ecc_verify_hash_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_API int wc_ecc_verify_hash_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmp__int.html">mp_int</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmp__int.html">mp_int</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>hashlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__key.html">ecc_key</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the return value to test for valid. Only use stat. </p>
<dl class="section return"><dt>Returns</dt><dd>MP_OKAY If successful (even if the signature is not valid) </dd>
<dd>
ECC_BAD_ARG_E Returns if arguments are null or if key-idx is invalid. </dd>
<dd>
MEMORY_E Error allocating ints or points.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The signature R component to verify </td></tr>
    <tr><td class="paramname">s</td><td>The signature S component to verify </td></tr>
    <tr><td class="paramname">hash</td><td>The hash (message digest) that was signed </td></tr>
    <tr><td class="paramname">hashlen</td><td>The length of the hash (octets) </td></tr>
    <tr><td class="paramname">stat</td><td>Result of signature, 1==valid, 0==invalid </td></tr>
    <tr><td class="paramname">key</td><td>The corresponding public ECC key <pre class="fragment">_Example_
</pre> <div class="fragment"><div class="line"><a class="code" href="structmp__int.html">mp_int</a> r;</div><div class="line"><a class="code" href="structmp__int.html">mp_int</a> s;</div><div class="line"><span class="keywordtype">int</span> stat;</div><div class="line">byte hash[] = { <span class="comment">// Some hash }</span></div><div class="line"><a class="code" href="structecc__key.html">ecc_key</a> key;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__ECC.html#ga24071ff7fd61458687dfd13f5129fdaa">wc_ecc_verify_hash_ex</a>(&amp;r, &amp;s, hash, hashlen, &amp;stat, &amp;key) == MP_OKAY)</div><div class="line">{</div><div class="line">    <span class="comment">// Check stat</span></div><div class="line">}</div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga89c60fc76d5566f23f73f43d31f29fe0" title="This function verifies the ECC signature of a hash to ensure authenticity. It returns the answer thro...">wc_ecc_verify_hash</a></dd></dl>
<p>Verify an ECC signature r The signature R component to verify s The signature S component to verify hash The hash (message digest) that was signed hashlen The length of the hash (octets) res Result of signature, 1==valid, 0==invalid key The corresponding public ECC key return MP_OKAY if successful (even if the signature is not valid) </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
